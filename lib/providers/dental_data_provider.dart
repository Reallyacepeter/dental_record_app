// import 'package:flutter/material.dart';
//
// class DentalDataProvider extends ChangeNotifier {
//   // üìå FDI ÏπòÏïÑÎ≥Ñ Îç∞Ïù¥ÌÑ∞
//   final Map<int, Map<String, dynamic>> fdiToothData = {};
//
//   // üìå 640: Í∏∞ÌÉÄ ÏÜåÍ≤¨
//   String otherFindings = "";
//
//   // üìå 645: ÏπòÏó¥ Ïú†Ìòï
//   String dentitionType = "";
//
//   // üìå 647: ÎÇòÏù¥ Ï∂îÏ†ï
//   int? ageMin;
//   int? ageMax;
//
//   // üìå 650: ÌíàÏßà ÌôïÏù∏
//   String qualityCheckSignature = "";
//   DateTime? qualityCheckDate;
//
//   // üìå 610: Materials Available
//   bool upperJawWithTeeth = false;
//   bool lowerJawWithTeeth = false;
//   bool upperJawWithoutTeeth = false;
//   bool lowerJawWithoutTeeth = false;
//   bool fragments = false;
//   String teethOnly = '';
//   String otherMaterials = '';
//
//   bool paDigital = false;
//   bool paNonDigital = false;
//   bool bwDigital = false;
//   bool bwNonDigital = false;
//   bool opgDigital = false;
//   bool opgNonDigital = false;
//   bool ctDigital = false;
//   bool ctNonDigital = false;
//   bool otherDigital = false;
//   bool otherNonDigital = false;
//   bool photographsDigital = false;
//   bool photographsNonDigital = false;
//   String otherRadiographs = '';
//   List<String> uploadedFiles = [];
//
//   String conditionOfJaws = '';
//   String otherDetails = '';
//
//   // üìå RecordScreen Í¥ÄÎ†® ÌïÑÎìú
//   String placeOfDisaster = '';
//   String natureOfDisaster = '';
//   String pmNumber = '';
//   DateTime? dateOfDisaster;
//   String gender = '';
//
//   // ===============================
//   //           SETTERS
//   // ===============================
//
//   void setToothDetail(int tooth, String detail) {
//     fdiToothData[tooth] = {"detail": detail};
//     notifyListeners();
//   }
//
//   void setOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void setDentitionType(String value) {
//     dentitionType = value;
//     notifyListeners();
//   }
//
//   void setAgeRange(int? min, int? max) {
//     ageMin = min;
//     ageMax = max;
//     notifyListeners();
//   }
//
//   void setQualityCheck(String signature, DateTime? date) {
//     qualityCheckSignature = signature;
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   void setMaterialsAvailable({
//     required bool upperWith,
//     required bool lowerWith,
//     required bool upperWithout,
//     required bool lowerWithout,
//     required bool hasFragments,
//     required String teethText,
//     required String otherText,
//   }) {
//     upperJawWithTeeth = upperWith;
//     lowerJawWithTeeth = lowerWith;
//     upperJawWithoutTeeth = upperWithout;
//     lowerJawWithoutTeeth = lowerWithout;
//     fragments = hasFragments;
//     teethOnly = teethText;
//     otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setEachMaterial({
//     bool? upperWith,
//     bool? lowerWith,
//     bool? upperWithout,
//     bool? lowerWithout,
//     bool? hasFragments,
//     String? teethText,
//     String? otherText,
//   }) {
//     if (upperWith != null) upperJawWithTeeth = upperWith;
//     if (lowerWith != null) lowerJawWithTeeth = lowerWith;
//     if (upperWithout != null) upperJawWithoutTeeth = upperWithout;
//     if (lowerWithout != null) lowerJawWithoutTeeth = lowerWithout;
//     if (hasFragments != null) fragments = hasFragments;
//     if (teethText != null) teethOnly = teethText;
//     if (otherText != null) otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setDentalImages({
//     bool? paD, bool? paND,
//     bool? bwD, bool? bwND,
//     bool? opgD, bool? opgND,
//     bool? ctD, bool? ctND,
//     bool? otherD, bool? otherND,
//     bool? photoD, bool? photoND,
//     String? otherRadio,
//     List<String>? uploads,
//   }) {
//     if (paD != null) paDigital = paD;
//     if (paND != null) paNonDigital = paND;
//     if (bwD != null) bwDigital = bwD;
//     if (bwND != null) bwNonDigital = bwND;
//     if (opgD != null) opgDigital = opgD;
//     if (opgND != null) opgNonDigital = opgND;
//     if (ctD != null) ctDigital = ctD;
//     if (ctND != null) ctNonDigital = ctND;
//     if (otherD != null) otherDigital = otherD;
//     if (otherND != null) otherNonDigital = otherND;
//     if (photoD != null) photographsDigital = photoD;
//     if (photoND != null) photographsNonDigital = photoND;
//     if (otherRadio != null) otherRadiographs = otherRadio;
//     if (uploads != null) uploadedFiles = uploads;
//     notifyListeners();
//   }
//
//   void setConditionOfJaws(String value) {
//     conditionOfJaws = value;
//     notifyListeners();
//   }
//
//   void setOtherDetails(String value) {
//     otherDetails = value;
//     notifyListeners();
//   }
//
//   void updateToothDetail(int toothNumber, String detail) {
//     fdiToothData[toothNumber] = {'detail': detail};
//     notifyListeners();
//   }
//
//   void updateOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void updateDentitionType(String type) {
//     dentitionType = type;
//     notifyListeners();
//   }
//
//   void updateAgeMin(int? value) {
//     ageMin = value;
//     notifyListeners();
//   }
//
//   void updateAgeMax(int? value) {
//     ageMax = value;
//     notifyListeners();
//   }
//
//   void updateQualitySignature(String value) {
//     qualityCheckSignature = value;
//     notifyListeners();
//   }
//
//   void updateQualityDate(DateTime date) {
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   // üìå RecordScreen Í¥ÄÎ†® setterÎì§
//   void updatePlace(String place) {
//     placeOfDisaster = place;
//     notifyListeners();
//   }
//
//   void updateNature(String nature) {
//     natureOfDisaster = nature;
//     notifyListeners();
//   }
//
//   void updatePmNumber(String pm) {
//     pmNumber = pm;
//     notifyListeners();
//   }
//
//   void updateDisasterDate(DateTime date) {
//     dateOfDisaster = date;
//     notifyListeners();
//   }
//
//   void updateGender(String selectedGender) {
//     gender = selectedGender;
//     notifyListeners();
//   }
//
//   // ===============================
//   //         FIREBASE Ï†ÄÏû•Ïö©
//   // ===============================
//
//   Map<String, dynamic> toMap() {
//     return {
//       'placeOfDisaster': placeOfDisaster,
//       'natureOfDisaster': natureOfDisaster,
//       'pmNumber': pmNumber,
//       'dateOfDisaster': dateOfDisaster?.toIso8601String(),
//       'gender': gender,
//
//       'fdiToothData': fdiToothData.map((k, v) => MapEntry(k.toString(), v)),
//       'otherFindings': otherFindings,
//       'dentitionType': dentitionType,
//       'ageMin': ageMin,
//       'ageMax': ageMax,
//       'qualityCheckSignature': qualityCheckSignature,
//       'qualityCheckDate': qualityCheckDate?.toIso8601String(),
//
//       // Materials Available
//       'upperJawWithTeeth': upperJawWithTeeth,
//       'lowerJawWithTeeth': lowerJawWithTeeth,
//       'upperJawWithoutTeeth': upperJawWithoutTeeth,
//       'lowerJawWithoutTeeth': lowerJawWithoutTeeth,
//       'fragments': fragments,
//       'teethOnly': teethOnly,
//       'otherMaterials': otherMaterials,
//
//       // Dental Images
//       'paDigital': paDigital,
//       'paNonDigital': paNonDigital,
//       'bwDigital': bwDigital,
//       'bwNonDigital': bwNonDigital,
//       'opgDigital': opgDigital,
//       'opgNonDigital': opgNonDigital,
//       'ctDigital': ctDigital,
//       'ctNonDigital': ctNonDigital,
//       'otherDigital': otherDigital,
//       'otherNonDigital': otherNonDigital,
//       'photographsDigital': photographsDigital,
//       'photographsNonDigital': photographsNonDigital,
//       'otherRadiographs': otherRadiographs,
//       'uploadedFiles': uploadedFiles,
//
//       // Jaws and Additional Notes
//       'conditionOfJaws': conditionOfJaws,
//       'otherDetails': otherDetails,
//     };
//   }
// }

// import 'package:flutter/material.dart';
//
// class DentalDataProvider extends ChangeNotifier {
//   // üìå FDI ÏπòÏïÑÎ≥Ñ Îç∞Ïù¥ÌÑ∞
//   final Map<int, Map<String, dynamic>> fdiToothData = {};
//
//   // üìå 640: Í∏∞ÌÉÄ ÏÜåÍ≤¨
//   String otherFindings = "";
//
//   // üìå 645: ÏπòÏó¥ Ïú†Ìòï
//   String dentitionType = "";
//
//   // üìå 647: ÎÇòÏù¥ Ï∂îÏ†ï
//   int? ageMin;
//   int? ageMax;
//
//   // üìå 650: ÌíàÏßà ÌôïÏù∏
//   String qualityCheckSignature = "";
//   DateTime? qualityCheckDate;
//
//   // üìå 610: Materials Available
//   bool upperJawWithTeeth = false;
//   bool lowerJawWithTeeth = false;
//   bool upperJawWithoutTeeth = false;
//   bool lowerJawWithoutTeeth = false;
//   bool fragments = false;
//   String teethOnly = '';
//   String otherMaterials = '';
//
//   bool paDigital = false;
//   bool paNonDigital = false;
//   bool bwDigital = false;
//   bool bwNonDigital = false;
//   bool opgDigital = false;
//   bool opgNonDigital = false;
//   bool ctDigital = false;
//   bool ctNonDigital = false;
//   bool otherDigital = false;
//   bool otherNonDigital = false;
//   bool photographsDigital = false;
//   bool photographsNonDigital = false;
//   String otherRadiographs = '';
//   List<String> uploadedFiles = [];
//
//   String conditionOfJaws = '';
//   String otherDetails = '';
//
//   // üìå RecordScreen Í¥ÄÎ†® ÌïÑÎìú
//   String placeOfDisaster = '';
//   String natureOfDisaster = '';
//   String pmNumber = '';
//   DateTime? dateOfDisaster;
//   String gender = '';
//
//   // ===============================
//   //           SETTERS
//   // ===============================
//
//   void setToothDetail(int tooth, String detail) {
//     fdiToothData[tooth] = {"detail": detail};
//     notifyListeners();
//   }
//
//   void setOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void setDentitionType(String value) {
//     dentitionType = value;
//     notifyListeners();
//   }
//
//   void setAgeRange(int? min, int? max) {
//     ageMin = min;
//     ageMax = max;
//     notifyListeners();
//   }
//
//   void setQualityCheck(String signature, DateTime? date) {
//     qualityCheckSignature = signature;
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   void setMaterialsAvailable({
//     required bool upperWith,
//     required bool lowerWith,
//     required bool upperWithout,
//     required bool lowerWithout,
//     required bool hasFragments,
//     required String teethText,
//     required String otherText,
//   }) {
//     upperJawWithTeeth = upperWith;
//     lowerJawWithTeeth = lowerWith;
//     upperJawWithoutTeeth = upperWithout;
//     lowerJawWithoutTeeth = lowerWithout;
//     fragments = hasFragments;
//     teethOnly = teethText;
//     otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setEachMaterial({
//     bool? upperWith,
//     bool? lowerWith,
//     bool? upperWithout,
//     bool? lowerWithout,
//     bool? hasFragments,
//     String? teethText,
//     String? otherText,
//   }) {
//     if (upperWith != null) upperJawWithTeeth = upperWith;
//     if (lowerWith != null) lowerJawWithTeeth = lowerWith;
//     if (upperWithout != null) upperJawWithoutTeeth = upperWithout;
//     if (lowerWithout != null) lowerJawWithoutTeeth = lowerWithout;
//     if (hasFragments != null) fragments = hasFragments;
//     if (teethText != null) teethOnly = teethText;
//     if (otherText != null) otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setDentalImages({
//     bool? paD, bool? paND,
//     bool? bwD, bool? bwND,
//     bool? opgD, bool? opgND,
//     bool? ctD, bool? ctND,
//     bool? otherD, bool? otherND,
//     bool? photoD, bool? photoND,
//     String? otherRadio,
//     List<String>? uploads,
//   }) {
//     if (paD != null) paDigital = paD;
//     if (paND != null) paNonDigital = paND;
//     if (bwD != null) bwDigital = bwD;
//     if (bwND != null) bwNonDigital = bwND;
//     if (opgD != null) opgDigital = opgD;
//     if (opgND != null) opgNonDigital = opgND;
//     if (ctD != null) ctDigital = ctD;
//     if (ctND != null) ctNonDigital = ctND;
//     if (otherD != null) otherDigital = otherD;
//     if (otherND != null) otherNonDigital = otherND;
//     if (photoD != null) photographsDigital = photoD;
//     if (photoND != null) photographsNonDigital = photoND;
//     if (otherRadio != null) otherRadiographs = otherRadio;
//     if (uploads != null) uploadedFiles = uploads;
//     notifyListeners();
//   }
//
//   void setConditionOfJaws(String value) {
//     conditionOfJaws = value;
//     notifyListeners();
//   }
//
//   void setOtherDetails(String value) {
//     otherDetails = value;
//     notifyListeners();
//   }
//
//   void updateToothDetail(int toothNumber, String detail) {
//     fdiToothData[toothNumber] = {'detail': detail};
//     notifyListeners();
//   }
//
//   void updateOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void updateDentitionType(String type) {
//     dentitionType = type;
//     notifyListeners();
//   }
//
//   void updateAgeMin(int? value) {
//     ageMin = value;
//     notifyListeners();
//   }
//
//   void updateAgeMax(int? value) {
//     ageMax = value;
//     notifyListeners();
//   }
//
//   void updateQualitySignature(String value) {
//     qualityCheckSignature = value;
//     notifyListeners();
//   }
//
//   void updateQualityDate(DateTime date) {
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   // üìå RecordScreen Í¥ÄÎ†® setterÎì§
//   void updatePlace(String place) {
//     placeOfDisaster = place;
//     notifyListeners();
//   }
//
//   void updateNature(String nature) {
//     natureOfDisaster = nature;
//     notifyListeners();
//   }
//
//   void updatePmNumber(String pm) {
//     pmNumber = pm;
//     notifyListeners();
//   }
//
//   void updateDisasterDate(DateTime date) {
//     dateOfDisaster = date;
//     notifyListeners();
//   }
//
//   void updateGender(String selectedGender) {
//     gender = selectedGender;
//     notifyListeners();
//   }
//
//   void setFdiToothData(Map<int, Map<String, String>> newData) {
//     fdiToothData.clear();
//     fdiToothData.addAll(newData);
//     notifyListeners();
//   }
//
//   void resetAll() {
//     // FDI ÏπòÏïÑÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
//     fdiToothData.clear();
//
//     // Íµ¨Í∞ï Ï†ïÎ≥¥
//     otherFindings = "";
//     dentitionType = "";
//     ageMin = null;
//     ageMax = null;
//     qualityCheckSignature = "";
//     qualityCheckDate = null;
//
//     // Materials Available
//     upperJawWithTeeth = false;
//     lowerJawWithTeeth = false;
//     upperJawWithoutTeeth = false;
//     lowerJawWithoutTeeth = false;
//     fragments = false;
//     teethOnly = '';
//     otherMaterials = '';
//
//     // Radiographs
//     paDigital = false;
//     paNonDigital = false;
//     bwDigital = false;
//     bwNonDigital = false;
//     opgDigital = false;
//     opgNonDigital = false;
//     ctDigital = false;
//     ctNonDigital = false;
//     otherDigital = false;
//     otherNonDigital = false;
//     photographsDigital = false;
//     photographsNonDigital = false;
//     otherRadiographs = '';
//     uploadedFiles = [];
//
//     // ÌÑ± ÏÉÅÌÉú Î∞è Í∏∞ÌÉÄ
//     conditionOfJaws = '';
//     otherDetails = '';
//
//     // RecordScreen Í¥ÄÎ†® ÌïÑÎìú
//     placeOfDisaster = '';
//     natureOfDisaster = '';
//     pmNumber = '';
//     dateOfDisaster = null;
//     gender = '';
//
//     notifyListeners();
//   }
//
//   void addUploadedFile(String fileUrl) {
//     uploadedFiles.add(fileUrl);
//     notifyListeners();
//   }
//
//   void removeUploadedFile(String fileUrl) {
//     uploadedFiles.remove(fileUrl);
//     notifyListeners();
//   }
//
//   // ===============================
//   //         FIREBASE Ï†ÄÏû•Ïö©
//   // ===============================
//
//   Map<String, dynamic> toMap() {
//     return {
//       'placeOfDisaster': placeOfDisaster,
//       'natureOfDisaster': natureOfDisaster,
//       'pmNumber': pmNumber,
//       'dateOfDisaster': dateOfDisaster?.toIso8601String(),
//       'gender': gender,
//
//       'fdiToothData': fdiToothData.map((k, v) => MapEntry(k.toString(), v)),
//       'otherFindings': otherFindings,
//       'dentitionType': dentitionType,
//       'ageMin': ageMin,
//       'ageMax': ageMax,
//       'qualityCheckSignature': qualityCheckSignature,
//       'qualityCheckDate': qualityCheckDate?.toIso8601String(),
//
//       'upperJawWithTeeth': upperJawWithTeeth,
//       'lowerJawWithTeeth': lowerJawWithTeeth,
//       'upperJawWithoutTeeth': upperJawWithoutTeeth,
//       'lowerJawWithoutTeeth': lowerJawWithoutTeeth,
//       'fragments': fragments,
//       'teethOnly': teethOnly,
//       'otherMaterials': otherMaterials,
//
//       'paDigital': paDigital,
//       'paNonDigital': paNonDigital,
//       'bwDigital': bwDigital,
//       'bwNonDigital': bwNonDigital,
//       'opgDigital': opgDigital,
//       'opgNonDigital': opgNonDigital,
//       'ctDigital': ctDigital,
//       'ctNonDigital': ctNonDigital,
//       'otherDigital': otherDigital,
//       'otherNonDigital': otherNonDigital,
//       'photographsDigital': photographsDigital,
//       'photographsNonDigital': photographsNonDigital,
//       'otherRadiographs': otherRadiographs,
//       'uploadedFiles': uploadedFiles,
//
//       'conditionOfJaws': conditionOfJaws,
//       'otherDetails': otherDetails,
//     };
//   }
// }

// import 'package:flutter/material.dart';
// import 'package:shared_preferences/shared_preferences.dart';
//
// class DentalDataProvider extends ChangeNotifier {
//
//   // üìå Í∏∞Î°ù Ïú†Ìòï(PM/AM) + AM Î≤àÌò∏
//   String recordType = 'PM';   // 'PM' ÎòêÎäî 'AM'
//   String amNumber = '';
//
//   // üìå FDI ÏπòÏïÑÎ≥Ñ Îç∞Ïù¥ÌÑ∞
//   final Map<int, Map<String, dynamic>> fdiToothData = {};
//
//   // DentalDataProvider ÏÉùÏÑ±ÏûêÏóê Î°úÎìú Ìò∏Ï∂ú
//   DentalDataProvider() {
//     _loadIncidentPrefs(); // Ïï± ÏãúÏûë Ïãú Ï†ÄÏû•Îêú Ïû†Í∏à ÏÉÅÌÉú/Í∞í Î≥µÍµ¨
//   }
//
// // ÌÇ§ ÏÉÅÏàò
//   static const _kLockEnabledKey = 'incidentLockEnabled';
//   static const _kLockedPlaceKey = 'lockedPlace';
//   static const _kLockedNatureKey = 'lockedNature';
//
// // Ï†ÄÏû•Îêú Í∞í Î∂àÎü¨Ïò§Í∏∞
//   Future<void> _loadIncidentPrefs() async {
//     final prefs = await SharedPreferences.getInstance();
//     incidentLockEnabled = prefs.getBool(_kLockEnabledKey) ?? false;
//     lockedPlace = prefs.getString(_kLockedPlaceKey) ?? '';
//     lockedNature = prefs.getString(_kLockedNatureKey) ?? '';
//     notifyListeners();
//   }
//
// // Ï†ÄÏû•ÌïòÍ∏∞
//   Future<void> _saveIncidentPrefs() async {
//     final prefs = await SharedPreferences.getInstance();
//     await prefs.setBool(_kLockEnabledKey, incidentLockEnabled);
//     await prefs.setString(_kLockedPlaceKey, lockedPlace);
//     await prefs.setString(_kLockedNatureKey, lockedNature);
//   }
//
//   // üìå 640: Í∏∞ÌÉÄ ÏÜåÍ≤¨
//   String otherFindings = "";
//
//   // üìå 645: ÏπòÏó¥ Ïú†Ìòï
//   String dentitionType = "";
//
//   // üìå 647: ÎÇòÏù¥ Ï∂îÏ†ï
//   int? ageMin;
//   int? ageMax;
//
//   // üìå 650: ÌíàÏßà ÌôïÏù∏
//   String qualityCheckSignature = "";
//   DateTime? qualityCheckDate;
//
//   // üìå 610: Materials Available
//   bool upperJawWithTeeth = false;
//   bool lowerJawWithTeeth = false;
//   bool upperJawWithoutTeeth = false;
//   bool lowerJawWithoutTeeth = false;
//   bool fragments = false;
//   String teethOnly = '';
//   String otherMaterials = '';
//
//   bool paDigital = false;
//   bool paNonDigital = false;
//   bool bwDigital = false;
//   bool bwNonDigital = false;
//   bool opgDigital = false;
//   bool opgNonDigital = false;
//   bool ctDigital = false;
//   bool ctNonDigital = false;
//   bool otherDigital = false;
//   bool otherNonDigital = false;
//   bool photographsDigital = false;
//   bool photographsNonDigital = false;
//   String otherRadiographs = '';
//   List<String> uploadedFiles = [];
//
//   String conditionOfJaws = '';
//   String otherDetails = '';
//
//   // üìå RecordScreen Í¥ÄÎ†® ÌïÑÎìú (ÏÇ¨Ïö©Ïûê ÏûÖÎ†• ÏõêÎ≥∏)
//   String placeOfDisaster = '';
//   String natureOfDisaster = '';
//   String pmNumber = '';
//   DateTime? dateOfDisaster;
//   String gender = '';
//
//   // ===============================
//   //  Incident Lock (Ï¥àÍ∏∞ OFF, Í∞í ÎπÑÏñ¥ÏûàÏùå)
//   // ===============================
//   bool incidentLockEnabled = false;
//   String lockedPlace = '';
//   String lockedNature = '';
//
//   /// UI/Ï†ÄÏû•Ïö©: Ïû†Í∏à+Í≥†Ï†ïÍ∞í Ï°¥Ïû¨ Ïãú Í≥†Ï†ïÍ∞í, ÏïÑÎãàÎ©¥ ÏÇ¨Ïö©Ïûê ÏûÖÎ†•Í∞í
//   String get placeForUi =>
//       (incidentLockEnabled && lockedPlace.isNotEmpty) ? lockedPlace : placeOfDisaster;
//   String get natureForUi =>
//       (incidentLockEnabled && lockedNature.isNotEmpty) ? lockedNature : natureOfDisaster;
//
//   /// Í≥†Ï†ïÍ∞í ÏÑ§Ï†ï
//   void setLockedValues({String? place, String? nature}) {
//     if (place != null) lockedPlace = place;
//     if (nature != null) lockedNature = nature;
//     notifyListeners();
//     _saveIncidentPrefs();
//   }
//
//   void setLockedPlace(String v) {
//     lockedPlace = v;
//     notifyListeners();
//   }
//
//   void setLockedNature(String v) {
//     lockedNature = v;
//     notifyListeners();
//   }
//
//   /// Ïû†Í∏à ON (Í≥†Ï†ïÍ∞íÏù¥ Î™®Îëê ÏûàÏñ¥Ïïº true)
//   bool enableIncidentLock({String? place, String? nature}) {
//     if (place != null) lockedPlace = place;
//     if (nature != null) lockedNature = nature;
//     if (lockedPlace.isEmpty || lockedNature.isEmpty) {
//       return false; // Í∞í ÏóÜÏúºÎ©¥ Ïã§Ìå®
//     }
//     incidentLockEnabled = true;
//     notifyListeners();
//     _saveIncidentPrefs();
//     return true;
//   }
//
//   /// Ïû†Í∏à OFF
//   void disableIncidentLock() {
//     incidentLockEnabled = false;
//     notifyListeners();
//     _saveIncidentPrefs();
//   }
//
//   void updateRecordType(String type) {
//     if (type != 'PM' && type != 'AM') return; // Ïú†Ìö®ÏÑ± Ï≤¥ÌÅ¨
//     if (recordType == type) return;           // ÎèôÏùº Í∞íÏù¥Î©¥ Î¨¥Ïãú
//     recordType = type;
//     notifyListeners();
//   }
//
//   void updateAmNumber(String value) {
//     if (amNumber == value) return;            // ÎèôÏùº Í∞íÏù¥Î©¥ Î¨¥Ïãú
//     amNumber = value;
//     notifyListeners();
//   }
//
//   // ===============================
//   //           SETTERS
//   // ===============================
//   void setToothDetail(int tooth, String detail) {
//     fdiToothData[tooth] = {"detail": detail};
//     notifyListeners();
//   }
//
//   void setOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void setDentitionType(String value) {
//     dentitionType = value;
//     notifyListeners();
//   }
//
//   void setAgeRange(int? min, int? max) {
//     ageMin = min;
//     ageMax = max;
//     notifyListeners();
//   }
//
//   void setQualityCheck(String signature, DateTime? date) {
//     qualityCheckSignature = signature;
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   void setMaterialsAvailable({
//     required bool upperWith,
//     required bool lowerWith,
//     required bool upperWithout,
//     required bool lowerWithout,
//     required bool hasFragments,
//     required String teethText,
//     required String otherText,
//   }) {
//     upperJawWithTeeth = upperWith;
//     lowerJawWithTeeth = lowerWith;
//     upperJawWithoutTeeth = upperWithout;
//     lowerJawWithoutTeeth = lowerWithout;
//     fragments = hasFragments;
//     teethOnly = teethText;
//     otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setEachMaterial({
//     bool? upperWith,
//     bool? lowerWith,
//     bool? upperWithout,
//     bool? lowerWithout,
//     bool? hasFragments,
//     String? teethText,
//     String? otherText,
//   }) {
//     if (upperWith != null) upperJawWithTeeth = upperWith;
//     if (lowerWith != null) lowerJawWithTeeth = lowerWith;
//     if (upperWithout != null) upperJawWithoutTeeth = upperWithout;
//     if (lowerWithout != null) lowerJawWithoutTeeth = lowerWithout;
//     if (hasFragments != null) fragments = hasFragments;
//     if (teethText != null) teethOnly = teethText;
//     if (otherText != null) otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setDentalImages({
//     bool? paD,
//     bool? paND,
//     bool? bwD,
//     bool? bwND,
//     bool? opgD,
//     bool? opgND,
//     bool? ctD,
//     bool? ctND,
//     bool? otherD,
//     bool? otherND,
//     bool? photoD,
//     bool? photoND,
//     String? otherRadio,
//     List<String>? uploads,
//   }) {
//     if (paD != null) paDigital = paD;
//     if (paND != null) paNonDigital = paND;
//     if (bwD != null) bwDigital = bwD;
//     if (bwND != null) bwNonDigital = bwND;
//     if (opgD != null) opgDigital = opgD;
//     if (opgND != null) opgNonDigital = opgND;
//     if (ctD != null) ctDigital = ctD;
//     if (ctND != null) ctNonDigital = ctND;
//     if (otherD != null) otherDigital = otherD;
//     if (otherND != null) otherNonDigital = otherND;
//     if (photoD != null) photographsDigital = photoD;
//     if (photoND != null) photographsNonDigital = photoND;
//     if (otherRadio != null) otherRadiographs = otherRadio;
//     if (uploads != null) uploadedFiles = uploads;
//     notifyListeners();
//   }
//
//   void setConditionOfJaws(String value) {
//     conditionOfJaws = value;
//     notifyListeners();
//   }
//
//   void setOtherDetails(String value) {
//     otherDetails = value;
//     notifyListeners();
//   }
//
//   void updateToothDetail(int toothNumber, String detail) {
//     fdiToothData[toothNumber] = {'detail': detail};
//     notifyListeners();
//   }
//
//   void updateOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void updateDentitionType(String type) {
//     dentitionType = type;
//     notifyListeners();
//   }
//
//   void updateAgeMin(int? value) {
//     ageMin = value;
//     notifyListeners();
//   }
//
//   void updateAgeMax(int? value) {
//     ageMax = value;
//     notifyListeners();
//   }
//
//   void updateQualitySignature(String value) {
//     qualityCheckSignature = value;
//     notifyListeners();
//   }
//
//   void updateQualityDate(DateTime date) {
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   // üìå RecordScreen Í¥ÄÎ†® setterÎì§
//   void updatePlace(String place) {
//     if (incidentLockEnabled) return; // Ïû†Í∏à Ïãú Î¨¥Ïãú
//     placeOfDisaster = place;
//     notifyListeners();
//   }
//
//   void updateNature(String nature) {
//     if (incidentLockEnabled) return; // Ïû†Í∏à Ïãú Î¨¥Ïãú
//     natureOfDisaster = nature;
//     notifyListeners();
//   }
//
//   void updatePmNumber(String pm) {
//     pmNumber = pm;
//     notifyListeners();
//   }
//
//   void updateDisasterDate(DateTime date) {
//     dateOfDisaster = date;
//     notifyListeners();
//   }
//
//   void updateGender(String selectedGender) {
//     gender = selectedGender;
//     notifyListeners();
//   }
//
//   void setFdiToothData(Map<int, Map<String, String>> newData) {
//     fdiToothData.clear();
//     fdiToothData.addAll(newData);
//     notifyListeners();
//   }
//
//   void resetAll() {
//
//     recordType = 'PM';
//     amNumber = '';
//
//     // FDI ÏπòÏïÑÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
//     fdiToothData.clear();
//
//     // Íµ¨Í∞ï Ï†ïÎ≥¥
//     otherFindings = "";
//     dentitionType = "";
//     ageMin = null;
//     ageMax = null;
//     qualityCheckSignature = "";
//     qualityCheckDate = null;
//
//     // Materials Available
//     upperJawWithTeeth = false;
//     lowerJawWithTeeth = false;
//     upperJawWithoutTeeth = false;
//     lowerJawWithoutTeeth = false;
//     fragments = false;
//     teethOnly = '';
//     otherMaterials = '';
//
//     // Radiographs
//     paDigital = false;
//     paNonDigital = false;
//     bwDigital = false;
//     bwNonDigital = false;
//     opgDigital = false;
//     opgNonDigital = false;
//     ctDigital = false;
//     ctNonDigital = false;
//     otherDigital = false;
//     otherNonDigital = false;
//     photographsDigital = false;
//     photographsNonDigital = false;
//     otherRadiographs = '';
//     uploadedFiles = [];
//
//     // ÌÑ± ÏÉÅÌÉú Î∞è Í∏∞ÌÉÄ
//     conditionOfJaws = '';
//     otherDetails = '';
//
//     // RecordScreen Í¥ÄÎ†® ÌïÑÎìú
//     placeOfDisaster = '';
//     natureOfDisaster = '';
//     pmNumber = '';
//     dateOfDisaster = null;
//     gender = '';
//
//     // ‚ö† incidentLockEnabled / lockedPlace / lockedNature Îäî Ïú†ÏßÄ
//     notifyListeners();
//   }
//
//   void addUploadedFile(String fileUrl) {
//     uploadedFiles.add(fileUrl);
//     notifyListeners();
//   }
//
//   void removeUploadedFile(String fileUrl) {
//     uploadedFiles.remove(fileUrl);
//     notifyListeners();
//   }
//
//   // ===============================
//   //         FIREBASE Ï†ÄÏû•Ïö©
//   // ===============================
//   Map<String, dynamic> toMap() {
//     return {
//       'recordType': recordType,
//       'amNumber': amNumber,
//
//       // ‚úÖ Ïû†Í∏à Î∞òÏòÅ Í∞íÏúºÎ°ú Ï†ÄÏû•
//       'placeOfDisaster': placeForUi,
//       'natureOfDisaster': natureForUi,
//
//       'pmNumber': pmNumber,
//       'dateOfDisaster': dateOfDisaster?.toIso8601String(),
//       'gender': gender,
//
//       'fdiToothData': fdiToothData.map((k, v) => MapEntry(k.toString(), v)),
//       'otherFindings': otherFindings,
//       'dentitionType': dentitionType,
//       'ageMin': ageMin,
//       'ageMax': ageMax,
//       'qualityCheckSignature': qualityCheckSignature,
//       'qualityCheckDate': qualityCheckDate?.toIso8601String(),
//
//       'upperJawWithTeeth': upperJawWithTeeth,
//       'lowerJawWithTeeth': lowerJawWithTeeth,
//       'upperJawWithoutTeeth': upperJawWithoutTeeth,
//       'lowerJawWithoutTeeth': lowerJawWithoutTeeth,
//       'fragments': fragments,
//       'teethOnly': teethOnly,
//       'otherMaterials': otherMaterials,
//
//       'paDigital': paDigital,
//       'paNonDigital': paNonDigital,
//       'bwDigital': bwDigital,
//       'bwNonDigital': bwNonDigital,
//       'opgDigital': opgDigital,
//       'opgNonDigital': opgNonDigital,
//       'ctDigital': ctDigital,
//       'ctNonDigital': ctNonDigital,
//       'otherDigital': otherDigital,
//       'otherNonDigital': otherNonDigital,
//       'photographsDigital': photographsDigital,
//       'photographsNonDigital': photographsNonDigital,
//       'otherRadiographs': otherRadiographs,
//       'uploadedFiles': uploadedFiles,
//
//       'conditionOfJaws': conditionOfJaws,
//       'otherDetails': otherDetails,
//     };
//   }
// }

// import 'dart:async';
// import 'package:flutter/material.dart';
// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:firebase_auth/firebase_auth.dart';
//
// class DentalDataProvider extends ChangeNotifier {
//   // ===============================
//   //  Record type (PM/AM)
//   // ===============================
//   String recordType = 'PM'; // 'PM' or 'AM'
//   String amNumber = '';
//   String pmNumber = '';
//
//   // ===============================
//   //  Incident Lock (ÏõêÍ≤© Firestore Ïó∞Îèô)
//   // ===============================
//   bool incidentLockEnabled = false;
//   String lockedPlace = '';
//   String lockedNature = '';
//
//   /// Ïû†Í∏à Ï†ÅÏö© Ïãú: Í≥†Ï†ïÍ∞í, ÏïÑÎãàÎ©¥ ÏÇ¨Ïö©Ïûê ÏûÖÎ†•Í∞í
//   String get placeForUi =>
//       (incidentLockEnabled && lockedPlace.isNotEmpty) ? lockedPlace : placeOfDisaster;
//   String get natureForUi =>
//       (incidentLockEnabled && lockedNature.isNotEmpty) ? lockedNature : natureOfDisaster;
//
//   // Firestore Î¨∏ÏÑú Íµ¨ÎèÖ
//   final DocumentReference<Map<String, dynamic>> _lockDoc =
//   FirebaseFirestore.instance.collection('config').doc('incidentLock');
//   StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>? _lockSub;
//
//   DentalDataProvider() {
//     _listenIncidentLock(); // Ïï± ÏãúÏûë Ïãú ÏõêÍ≤© Ïû†Í∏à ÏÉÅÌÉúÎ•º Íµ¨ÎèÖ
//   }
//
//   void _listenIncidentLock() {
//     _lockSub = _lockDoc.snapshots().listen((snap) {
//       final d = snap.data();
//       if (d == null) return;
//       incidentLockEnabled = (d['enabled'] ?? false) as bool;
//       lockedPlace = (d['place'] ?? '') as String;
//       lockedNature = (d['nature'] ?? '') as String;
//       notifyListeners();
//     });
//   }
//
//   /// ÏõêÍ≤©Ïóê Ïû†Í∏à/Í≥†Ï†ïÍ∞í Ï†ÄÏû•(Î™®Îì† Í∏∞Í∏∞Ïóê Î∞òÏòÅ)
//   Future<void> setIncidentLockRemote({
//     required bool enabled,
//     required String place,
//     required String nature,
//   }) async {
//     if (enabled && (place.isEmpty || nature.isEmpty)) {
//       throw ArgumentError('Place/Nature required to enable incident lock.');
//     }
//     await _lockDoc.set({
//       'enabled': enabled,
//       'place': place,
//       'nature': nature,
//       'updatedAt': FieldValue.serverTimestamp(),
//       'byUid': FirebaseAuth.instance.currentUser?.uid,
//     }, SetOptions(merge: true));
//   }
//
//   @override
//   void dispose() {
//     _lockSub?.cancel();
//     super.dispose();
//   }
//
//   // ===============================
//   //  FDI ÏπòÏïÑ Îç∞Ïù¥ÌÑ∞ & Í∏∞ÌÉÄ ÌïÑÎìú
//   // ===============================
//   final Map<int, Map<String, dynamic>> fdiToothData = {};
//
//   String otherFindings = "";
//   String dentitionType = "";
//
//   int? ageMin;
//   int? ageMax;
//
//   String qualityCheckSignature = "";
//   DateTime? qualityCheckDate;
//
//   // 610: Materials Available
//   bool upperJawWithTeeth = false;
//   bool lowerJawWithTeeth = false;
//   bool upperJawWithoutTeeth = false;
//   bool lowerJawWithoutTeeth = false;
//   bool fragments = false;
//   String teethOnly = '';
//   String otherMaterials = '';
//
//   bool paDigital = false;
//   bool paNonDigital = false;
//   bool bwDigital = false;
//   bool bwNonDigital = false;
//   bool opgDigital = false;
//   bool opgNonDigital = false;
//   bool ctDigital = false;
//   bool ctNonDigital = false;
//   bool otherDigital = false;
//   bool otherNonDigital = false;
//   bool photographsDigital = false;
//   bool photographsNonDigital = false;
//   String otherRadiographs = '';
//   List<String> uploadedFiles = [];
//
//   String conditionOfJaws = '';
//   String otherDetails = '';
//
//   // RecordScreen Í¥ÄÎ†® ÏÇ¨Ïö©Ïûê ÏûÖÎ†• ÏõêÎ≥∏
//   String placeOfDisaster = '';
//   String natureOfDisaster = '';
//   DateTime? dateOfDisaster;
//   String gender = '';
//
//   // ===============================
//   //  Setters / Updaters
//   // ===============================
//   void updateRecordType(String type) {
//     if (type != 'PM' && type != 'AM') return;
//     if (recordType == type) return;
//     recordType = type;
//     notifyListeners();
//   }
//
//   void updateAmNumber(String value) {
//     if (amNumber == value) return;
//     amNumber = value;
//     notifyListeners();
//   }
//
//   void updatePmNumber(String pm) {
//     if (pmNumber == pm) return;
//     pmNumber = pm;
//     notifyListeners();
//   }
//
//   void updatePlace(String place) {
//     if (incidentLockEnabled) return; // Ïû†Í∏à Ïãú Î¨¥Ïãú
//     placeOfDisaster = place;
//     notifyListeners();
//   }
//
//   void updateNature(String nature) {
//     if (incidentLockEnabled) return; // Ïû†Í∏à Ïãú Î¨¥Ïãú
//     natureOfDisaster = nature;
//     notifyListeners();
//   }
//
//   void updateDisasterDate(DateTime date) {
//     dateOfDisaster = date;
//     notifyListeners();
//   }
//
//   void updateGender(String selectedGender) {
//     gender = selectedGender;
//     notifyListeners();
//   }
//
//   void updateToothDetail(int toothNumber, String detail) {
//     fdiToothData[toothNumber] = {'detail': detail};
//     notifyListeners();
//   }
//
//   void updateOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void updateDentitionType(String type) {
//     dentitionType = type;
//     notifyListeners();
//   }
//
//   void updateAgeMin(int? value) {
//     ageMin = value;
//     notifyListeners();
//   }
//
//   void updateAgeMax(int? value) {
//     ageMax = value;
//     notifyListeners();
//   }
//
//   void updateQualitySignature(String value) {
//     qualityCheckSignature = value;
//     notifyListeners();
//   }
//
//   void updateQualityDate(DateTime date) {
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   void setToothDetail(int tooth, String detail) {
//     fdiToothData[tooth] = {"detail": detail};
//     notifyListeners();
//   }
//
//   void setOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void setDentitionType(String value) {
//     dentitionType = value;
//     notifyListeners();
//   }
//
//   void setAgeRange(int? min, int? max) {
//     ageMin = min;
//     ageMax = max;
//     notifyListeners();
//   }
//
//   void setQualityCheck(String signature, DateTime? date) {
//     qualityCheckSignature = signature;
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   void setMaterialsAvailable({
//     required bool upperWith,
//     required bool lowerWith,
//     required bool upperWithout,
//     required bool lowerWithout,
//     required bool hasFragments,
//     required String teethText,
//     required String otherText,
//   }) {
//     upperJawWithTeeth = upperWith;
//     lowerJawWithTeeth = lowerWith;
//     upperJawWithoutTeeth = upperWithout;
//     lowerJawWithoutTeeth = lowerWithout;
//     fragments = hasFragments;
//     teethOnly = teethText;
//     otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setEachMaterial({
//     bool? upperWith,
//     bool? lowerWith,
//     bool? upperWithout,
//     bool? lowerWithout,
//     bool? hasFragments,
//     String? teethText,
//     String? otherText,
//   }) {
//     if (upperWith != null) upperJawWithTeeth = upperWith;
//     if (lowerWith != null) lowerJawWithTeeth = lowerWith;
//     if (upperWithout != null) upperJawWithoutTeeth = upperWithout;
//     if (lowerWithout != null) lowerJawWithoutTeeth = lowerWithout;
//     if (hasFragments != null) fragments = hasFragments;
//     if (teethText != null) teethOnly = teethText;
//     if (otherText != null) otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setDentalImages({
//     bool? paD,
//     bool? paND,
//     bool? bwD,
//     bool? bwND,
//     bool? opgD,
//     bool? opgND,
//     bool? ctD,
//     bool? ctND,
//     bool? otherD,
//     bool? otherND,
//     bool? photoD,
//     bool? photoND,
//     String? otherRadio,
//     List<String>? uploads,
//   }) {
//     if (paD != null) paDigital = paD;
//     if (paND != null) paNonDigital = paND;
//     if (bwD != null) bwDigital = bwD;
//     if (bwND != null) bwNonDigital = bwND;
//     if (opgD != null) opgDigital = opgD;
//     if (opgND != null) opgNonDigital = opgND;
//     if (ctD != null) ctDigital = ctD;
//     if (ctND != null) ctNonDigital = ctND;
//     if (otherD != null) otherDigital = otherD;
//     if (otherND != null) otherNonDigital = otherND;
//     if (photoD != null) photographsDigital = photoD;
//     if (photoND != null) photographsNonDigital = photoND;
//     if (otherRadio != null) otherRadiographs = otherRadio;
//     if (uploads != null) uploadedFiles = uploads;
//     notifyListeners();
//   }
//
//   void setConditionOfJaws(String value) {
//     conditionOfJaws = value;
//     notifyListeners();
//   }
//
//   void setOtherDetails(String value) {
//     otherDetails = value;
//     notifyListeners();
//   }
//
//   void setFdiToothData(Map<int, Map<String, String>> newData) {
//     fdiToothData.clear();
//     fdiToothData.addAll(newData);
//     notifyListeners();
//   }
//
//   void addUploadedFile(String fileUrl) {
//     uploadedFiles.add(fileUrl);
//     notifyListeners();
//   }
//
//   void removeUploadedFile(String fileUrl) {
//     uploadedFiles.remove(fileUrl);
//     notifyListeners();
//   }
//
//   // ===============================
//   //  Reset / Save
//   // ===============================
//   void resetAll() {
//     recordType = 'PM';
//     amNumber = '';
//     pmNumber = '';
//
//     fdiToothData.clear();
//
//     otherFindings = "";
//     dentitionType = "";
//     ageMin = null;
//     ageMax = null;
//     qualityCheckSignature = "";
//     qualityCheckDate = null;
//
//     upperJawWithTeeth = false;
//     lowerJawWithTeeth = false;
//     upperJawWithoutTeeth = false;
//     lowerJawWithoutTeeth = false;
//     fragments = false;
//     teethOnly = '';
//     otherMaterials = '';
//
//     paDigital = false;
//     paNonDigital = false;
//     bwDigital = false;
//     bwNonDigital = false;
//     opgDigital = false;
//     opgNonDigital = false;
//     ctDigital = false;
//     ctNonDigital = false;
//     otherDigital = false;
//     otherNonDigital = false;
//     photographsDigital = false;
//     photographsNonDigital = false;
//     otherRadiographs = '';
//     uploadedFiles = [];
//
//     conditionOfJaws = '';
//     otherDetails = '';
//
//     placeOfDisaster = '';
//     natureOfDisaster = '';
//     dateOfDisaster = null;
//     gender = '';
//
//     // incidentLockEnabled / lockedPlace / lockedNature Îäî FirestoreÏóêÏÑú Ïú†ÏßÄ/ÎèôÍ∏∞Ìôî
//     notifyListeners();
//   }
//
//   Map<String, dynamic> toMap() {
//     return {
//       'recordType': recordType,
//       'amNumber': amNumber,
//       'pmNumber': pmNumber,
//
//       // Ïû†Í∏à Î∞òÏòÅ Í∞íÏúºÎ°ú Ï†ÄÏû•
//       'placeOfDisaster': placeForUi,
//       'natureOfDisaster': natureForUi,
//
//       'dateOfDisaster': dateOfDisaster?.toIso8601String(),
//       'gender': gender,
//
//       'fdiToothData': fdiToothData.map((k, v) => MapEntry(k.toString(), v)),
//       'otherFindings': otherFindings,
//       'dentitionType': dentitionType,
//       'ageMin': ageMin,
//       'ageMax': ageMax,
//       'qualityCheckSignature': qualityCheckSignature,
//       'qualityCheckDate': qualityCheckDate?.toIso8601String(),
//
//       'upperJawWithTeeth': upperJawWithTeeth,
//       'lowerJawWithTeeth': lowerJawWithTeeth,
//       'upperJawWithoutTeeth': upperJawWithoutTeeth,
//       'lowerJawWithoutTeeth': lowerJawWithoutTeeth,
//       'fragments': fragments,
//       'teethOnly': teethOnly,
//       'otherMaterials': otherMaterials,
//
//       'paDigital': paDigital,
//       'paNonDigital': paNonDigital,
//       'bwDigital': bwDigital,
//       'bwNonDigital': bwNonDigital,
//       'opgDigital': opgDigital,
//       'opgNonDigital': opgNonDigital,
//       'ctDigital': ctDigital,
//       'ctNonDigital': ctNonDigital,
//       'otherDigital': otherDigital,
//       'otherNonDigital': otherNonDigital,
//       'photographsDigital': photographsDigital,
//       'photographsNonDigital': photographsNonDigital,
//       'otherRadiographs': otherRadiographs,
//       'uploadedFiles': uploadedFiles,
//
//       'conditionOfJaws': conditionOfJaws,
//       'otherDetails': otherDetails,
//     };
//   }
// }

// import 'dart:async';
// import 'package:flutter/material.dart';
// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:firebase_auth/firebase_auth.dart';
//
// /// 5Î©¥ ÌÇ§ Í≥†Ï†ï (Ï§ëÏïô O, ÏúÑ L, ÏïÑÎûò B, Ï¢å/Ïö∞Îäî M/D)
// const List<String> kToothSurfaces = ['O', 'M', 'D', 'L', 'B'];
//
// /// ÏπòÏãù ÌëúÍ∏∞(635)ÏóêÏÑú ÏÇ¨Ïö©Ìï† ÎßàÌÅ¨ ÌÉÄÏûÖ
// enum ToothMarkType { lesion, restoration, prosthesis, status, other }
//
// /// ÌïòÎÇòÏùò ÏΩîÎìú Ìï≠Î™© (Ïòà: "ABR", "AMF", "UIC" Îì±)
// class ToothMark {
//   final String code;                 // ÌïÑÏàò ÏΩîÎìú Î¨∏ÏûêÏó¥
//   final ToothMarkType type;          // Î∂ÑÎ•ò
//   final bool isParent;               // ÏÉÅÏúÑ Î†àÎ≤®Îßå Ïïå Îïå true (Ïòà: UIC, TCC)
//   final String? note;                // ÏÑ†ÌÉù Î©îÎ™®
//
//   const ToothMark({
//     required this.code,
//     this.type = ToothMarkType.other,
//     this.isParent = false,
//     this.note,
//   });
//
//   Map<String, dynamic> toJson() => {
//     'code': code,
//     'type': type.name,
//     'isParent': isParent,
//     'note': note,
//   };
//
//   factory ToothMark.fromJson(Map<String, dynamic> j) => ToothMark(
//     code: j['code'] as String,
//     type: ToothMarkType.values.firstWhere(
//           (e) => e.name == (j['type'] as String? ?? 'other'),
//       orElse: () => ToothMarkType.other,
//     ),
//     isParent: (j['isParent'] ?? false) as bool,
//     note: j['note'] as String?,
//   );
// }
//
// /// Ìïú ÏπòÏïÑÏùò Î™®Îì† Îç∞Ïù¥ÌÑ∞(Ï†ïÍ∑ú Íµ¨Ï°∞)
// class ToothFinding {
//   ToothFinding();
//   /// Î©¥Î≥Ñ ÏΩîÎìú Î™©Î°ù (O/M/D/L/B)
//   final Map<String, List<ToothMark>> surfaces = {
//     for (final s in kToothSurfaces) s: <ToothMark>[],
//   };
//
//   /// ÌôïÎåÄ ÌôîÎ©¥ÏóêÏÑú Îã®Ïàú Ï±ÑÏÉâ/ÏÑ†ÌÉùÎßåÏùÑ ÏúÑÌïú ÌëúÎ©¥ ÌÜ†Í∏Ä ÏÉÅÌÉú
//   final Set<String> selected = <String>{};
//
//   /// ÏπòÏïÑ Ï†ÑÏ≤¥(ÌëúÎ©¥ Î¨¥Í¥Ä) ÏΩîÎìú Î™©Î°ù (Status Îì±)
//   final List<ToothMark> global = <ToothMark>[];
//
//   /// Î©¥Î≥Ñ Î©îÎ™®
//   final Map<String, String> surfaceNote = <String, String>{};
//
//   /// ÏπòÏïÑ Ï†ÑÏ≤¥ Î©îÎ™®
//   String? toothNote;
//
//   Map<String, dynamic> toJson() => {
//     'surfaces': {
//       for (final e in surfaces.entries)
//         e.key: e.value.map((m) => m.toJson()).toList(),
//     },
//     'selected': selected.toList(),
//     'global': global.map((m) => m.toJson()).toList(),
//     'surfaceNote': surfaceNote,
//     'toothNote': toothNote,
//   };
//
//   factory ToothFinding.fromJson(Map<String, dynamic> j) {
//     final tf = ToothFinding();
//     final surf = (j['surfaces'] as Map?) ?? {};
//     for (final s in kToothSurfaces) {
//       final list = (surf[s] as List?) ?? const [];
//       tf.surfaces[s]!.addAll(list.map((e) => ToothMark.fromJson(Map<String, dynamic>.from(e))));
//     }
//     final sel = (j['selected'] as List?) ?? const [];
//     tf.selected.addAll(sel.map((e) => e.toString()));
//     final gl = (j['global'] as List?) ?? const [];
//     tf.global.addAll(gl.map((e) => ToothMark.fromJson(Map<String, dynamic>.from(e))));
//     final sn = (j['surfaceNote'] as Map?) ?? {};
//     tf.surfaceNote.addAll(sn.map((k, v) => MapEntry(k.toString(), v.toString())));
//     tf.toothNote = j['toothNote'] as String?;
//     return tf;
//   }
// }
//
// class DentalDataProvider extends ChangeNotifier {
//   // ----------------- Record / Incident lock -----------------
//   String recordType = 'PM';
//   String amNumber = '';
//   String pmNumber = '';
//
//   bool incidentLockEnabled = false;
//   String lockedPlace = '';
//   String lockedNature = '';
//   String get placeForUi =>
//       (incidentLockEnabled && lockedPlace.isNotEmpty) ? lockedPlace : placeOfDisaster;
//   String get natureForUi =>
//       (incidentLockEnabled && lockedNature.isNotEmpty) ? lockedNature : natureOfDisaster;
//
//   final DocumentReference<Map<String, dynamic>> _lockDoc =
//   FirebaseFirestore.instance.collection('config').doc('incidentLock');
//   StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>? _lockSub;
//
//   DentalDataProvider() {
//     _listenIncidentLock();
//   }
//
//   void _listenIncidentLock() {
//     _lockSub = _lockDoc.snapshots().listen((snap) {
//       final d = snap.data();
//       if (d == null) return;
//       incidentLockEnabled = (d['enabled'] ?? false) as bool;
//       lockedPlace = (d['place'] ?? '') as String;
//       lockedNature = (d['nature'] ?? '') as String;
//       notifyListeners();
//     });
//   }
//
//   Future<void> setIncidentLockRemote({
//     required bool enabled,
//     required String place,
//     required String nature,
//   }) async {
//     if (enabled && (place.isEmpty || nature.isEmpty)) {
//       throw ArgumentError('Place/Nature required to enable incident lock.');
//     }
//     await _lockDoc.set(
//       {
//         'enabled': enabled,
//         'place': place,
//         'nature': nature,
//         'updatedAt': FieldValue.serverTimestamp(),
//         'byUid': FirebaseAuth.instance.currentUser?.uid,
//       },
//       SetOptions(merge: true),
//     );
//   }
//
//   @override
//   void dispose() {
//     _lockSub?.cancel();
//     super.dispose();
//   }
//
//   // ----------------- Odontogram Îç∞Ïù¥ÌÑ∞ -----------------
//
//   /// (ÌïòÏúÑ Ìò∏Ìôò) Í∞ÑÎã® Î¨∏ÏûêÏó¥ Ï†ÄÏû•Ïö© ‚Äì ÏùºÎ∂Ä ÌôîÎ©¥Ïù¥ ÏÇ¨Ïö© Ï§ëÏùº Ïàò ÏûàÏñ¥ Ïú†ÏßÄ
//   final Map<int, Map<String, dynamic>> fdiToothData = <int, Map<String, dynamic>>{};
//
//   /// Ï†ïÍ∑ú Íµ¨Ï°∞
//   final Map<int, ToothFinding> teethFindings = <int, ToothFinding>{};
//
//   ToothFinding _getOrCreate(int fdi) =>
//       teethFindings.putIfAbsent(fdi, () => ToothFinding());
//
//   // ----- 5Î©¥ ÏÑ†ÌÉù(Ï±ÑÏÉâ) API -----
//   Set<String> getSelectedSurfaces(int fdi) {
//     final t = teethFindings[fdi];
//     if (t == null) return {};
//     // ÏÑ†ÌÉù ÌÜ†Í∏Ä + Ïã§Îç∞Ïù¥ÌÑ∞ Ï°¥Ïû¨Î©¥ ÏÑ†ÌÉùÏúºÎ°ú Í∞ÑÏ£º
//     final hasData = kToothSurfaces.where((s) => (t.surfaces[s]!.isNotEmpty) || t.surfaceNote.containsKey(s));
//     return {...t.selected, ...hasData};
//   }
//
//   void toggleSurface(int fdi, String surfaceKey) {
//     if (!kToothSurfaces.contains(surfaceKey)) return;
//     final t = _getOrCreate(fdi);
//     if (t.selected.contains(surfaceKey)) {
//       t.selected.remove(surfaceKey);
//     } else {
//       t.selected.add(surfaceKey);
//     }
//     notifyListeners();
//   }
//
//   void clearSurfaces(int fdi) {
//     final t = _getOrCreate(fdi);
//     t.selected.clear();
//     notifyListeners();
//   }
//
//   // ----- ÏΩîÎìú(635) / Î©îÎ™® -----
//   /// ÌëúÎ©¥Ïóê ÏΩîÎìú Ï∂îÍ∞Ä (surface == null Ïù¥Î©¥ ÏπòÏïÑ Ï†ÑÏó≠)
//   void addMark({
//     required int fdi,
//     String? surface,
//     required ToothMark mark,
//   }) {
//     final t = _getOrCreate(fdi);
//     if (surface == null) {
//       t.global.add(mark);
//     } else {
//       if (!kToothSurfaces.contains(surface)) return;
//       t.surfaces[surface]!.add(mark);
//     }
//     notifyListeners();
//   }
//
//   /// ÌäπÏ†ï ÌëúÎ©¥Ïùò ÏΩîÎìú/Î©îÎ™® Ï†ÑÏ≤¥ ÏÇ≠Ï†ú (ÏÑ†ÌÉù ÌÜ†Í∏ÄÏùÄ Ïú†ÏßÄ)
//   void clearSurfaceData(int fdi, String surface) {
//     final t = _getOrCreate(fdi);
//     if (!kToothSurfaces.contains(surface)) return;
//     t.surfaces[surface]!.clear();
//     t.surfaceNote.remove(surface);
//     notifyListeners();
//   }
//
//   /// ÏπòÏïÑ Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî(ÏÑ†ÌÉù/ÏΩîÎìú/Î©îÎ™® Î™®Îëê)
//   void clearTooth(int fdi) {
//     teethFindings.remove(fdi);
//     fdiToothData.remove(fdi);
//     notifyListeners();
//   }
//
//   void setSurfaceNote(int fdi, String surface, String note) {
//     if (!kToothSurfaces.contains(surface)) return;
//     final t = _getOrCreate(fdi);
//     t.surfaceNote[surface] = note;
//     notifyListeners();
//   }
//
//   void setToothNote(int fdi, String? note) {
//     final t = _getOrCreate(fdi);
//     final n = note?.trim();
//     t.toothNote = (n == null || n.isEmpty) ? null : n;
//     notifyListeners();
//   }
//
//   /// 635 Ï∂úÎ†•Ïö© Î¨∏ÏûêÏó¥ Ìïú Ï§Ñ ÏÉùÏÑ± (Ïòà: "ABR(M) ¬∑ AMF(O) ¬∑ UIC ¬∑ note:‚Ä¶")
//   String build635Line(int fdi) {
//     final t = teethFindings[fdi];
//     if (t == null) return '';
//     final out = <String>[];
//
//     for (final s in kToothSurfaces) {
//       final list = t.surfaces[s]!;
//       if (list.isEmpty) continue;
//       final codes = list.map((m) => m.code).join(',');
//       out.add('$codes($s)');
//     }
//     if (t.global.isNotEmpty) {
//       out.addAll(t.global.map((m) => m.code));
//     }
//     if (t.toothNote != null && t.toothNote!.isNotEmpty) {
//       out.add('note:${t.toothNote}');
//     }
//     return out.join(' ¬∑ ');
//   }
//
//   // ----- (ÌïòÏúÑ Ìò∏Ìôò) Í∞ÑÎã® Î¨∏ÏûêÏó¥ Î©îÎ™® -----
//   void setToothDetail(int tooth, String detail) {
//     fdiToothData[tooth] = {'detail': detail};
//     notifyListeners();
//   }
//
//   void bulkSetToothDetail(Iterable<int> teeth, String detail) {
//     for (final t in teeth) {
//       fdiToothData[t] = {'detail': detail};
//     }
//     notifyListeners();
//   }
//
//   void clearToothDetail(int tooth) {
//     fdiToothData.remove(tooth);
//     notifyListeners();
//   }
//
//   // ----------------- ÎÇòÎ®∏ÏßÄ Ìèº ÌïÑÎìú -----------------
//   String otherFindings = "";
//   String dentitionType = "";
//   int? ageMin;
//   int? ageMax;
//   String qualityCheckSignature = "";
//   DateTime? qualityCheckDate;
//
//   // 610 Materials Available
//   bool upperJawWithTeeth = false;
//   bool lowerJawWithTeeth = false;
//   bool upperJawWithoutTeeth = false;
//   bool lowerJawWithoutTeeth = false;
//   bool fragments = false;
//   String teethOnly = '';
//   String otherMaterials = '';
//
//   // Radiographs
//   bool paDigital = false;
//   bool paNonDigital = false;
//   bool bwDigital = false;
//   bool bwNonDigital = false;
//   bool opgDigital = false;
//   bool opgNonDigital = false;
//   bool ctDigital = false;
//   bool ctNonDigital = false;
//   bool otherDigital = false;
//   bool otherNonDigital = false;
//   bool photographsDigital = false;
//   bool photographsNonDigital = false;
//   String otherRadiographs = '';
//   List<String> uploadedFiles = [];
//
//   String conditionOfJaws = '';
//   String otherDetails = '';
//
//   // RecordScreen ÏõêÎ≥∏ ÏûÖÎ†•
//   String placeOfDisaster = '';
//   String natureOfDisaster = '';
//   DateTime? dateOfDisaster;
//   String gender = '';
//
//   // ----------------- Updaters -----------------
//   void updateRecordType(String type) {
//     if (type != 'PM' && type != 'AM') return;
//     if (recordType == type) return;
//     recordType = type;
//     notifyListeners();
//   }
//
//   void updateAmNumber(String value) {
//     if (amNumber == value) return;
//     amNumber = value;
//     notifyListeners();
//   }
//
//   void updatePmNumber(String pm) {
//     if (pmNumber == pm) return;
//     pmNumber = pm;
//     notifyListeners();
//   }
//
//   void updatePlace(String place) {
//     if (incidentLockEnabled) return;
//     placeOfDisaster = place;
//     notifyListeners();
//   }
//
//   void updateNature(String nature) {
//     if (incidentLockEnabled) return;
//     natureOfDisaster = nature;
//     notifyListeners();
//   }
//
//   void updateDisasterDate(DateTime date) {
//     dateOfDisaster = date;
//     notifyListeners();
//   }
//
//   void updateGender(String selectedGender) {
//     gender = selectedGender;
//     notifyListeners();
//   }
//
//   void updateOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void updateDentitionType(String type) {
//     dentitionType = type;
//     notifyListeners();
//   }
//
//   void updateAgeMin(int? value) {
//     ageMin = value;
//     notifyListeners();
//   }
//
//   void updateAgeMax(int? value) {
//     ageMax = value;
//     notifyListeners();
//   }
//
//   void updateQualitySignature(String value) {
//     qualityCheckSignature = value;
//     notifyListeners();
//   }
//
//   void updateQualityDate(DateTime date) {
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   void setMaterialsAvailable({
//     required bool upperWith,
//     required bool lowerWith,
//     required bool upperWithout,
//     required bool lowerWithout,
//     required bool hasFragments,
//     required String teethText,
//     required String otherText,
//   }) {
//     upperJawWithTeeth = upperWith;
//     lowerJawWithTeeth = lowerWith;
//     upperJawWithoutTeeth = upperWithout;
//     lowerJawWithoutTeeth = lowerWithout;
//     fragments = hasFragments;
//     teethOnly = teethText;
//     otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setEachMaterial({
//     bool? upperWith,
//     bool? lowerWith,
//     bool? upperWithout,
//     bool? lowerWithout,
//     bool? hasFragments,
//     String? teethText,
//     String? otherText,
//   }) {
//     if (upperWith != null) upperJawWithTeeth = upperWith;
//     if (lowerWith != null) lowerJawWithTeeth = lowerWith;
//     if (upperWithout != null) upperJawWithoutTeeth = upperWithout;
//     if (lowerWithout != null) lowerJawWithoutTeeth = lowerWithout;
//     if (hasFragments != null) fragments = hasFragments;
//     if (teethText != null) teethOnly = teethText;
//     if (otherText != null) otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setDentalImages({
//     bool? paD,
//     bool? paND,
//     bool? bwD,
//     bool? bwND,
//     bool? opgD,
//     bool? opgND,
//     bool? ctD,
//     bool? ctND,
//     bool? otherD,
//     bool? otherND,
//     bool? photoD,
//     bool? photoND,
//     String? otherRadio,
//     List<String>? uploads,
//   }) {
//     if (paD != null) paDigital = paD;
//     if (paND != null) paNonDigital = paND;
//     if (bwD != null) bwDigital = bwD;
//     if (bwND != null) bwNonDigital = bwND;
//     if (opgD != null) opgDigital = opgD;
//     if (opgND != null) opgNonDigital = opgND;
//     if (ctD != null) ctDigital = ctD;
//     if (ctND != null) ctNonDigital = ctND;
//     if (otherD != null) otherDigital = otherD;
//     if (otherND != null) otherNonDigital = otherND;
//     if (photoD != null) photographsDigital = photoD;
//     if (photoND != null) photographsNonDigital = photoND;
//     if (otherRadio != null) otherRadiographs = otherRadio;
//     if (uploads != null) uploadedFiles = uploads;
//     notifyListeners();
//   }
//
//   void setConditionOfJaws(String value) {
//     conditionOfJaws = value;
//     notifyListeners();
//   }
//
//   void setOtherDetails(String value) {
//     otherDetails = value;
//     notifyListeners();
//   }
//
//   void setFdiToothData(Map<int, Map<String, String>> newData) {
//     fdiToothData.clear();
//     fdiToothData.addAll(newData);
//     notifyListeners();
//   }
//
//   void addUploadedFile(String fileUrl) {
//     uploadedFiles.add(fileUrl);
//     notifyListeners();
//   }
//
//   void removeUploadedFile(String fileUrl) {
//     uploadedFiles.remove(fileUrl);
//     notifyListeners();
//   }
//
//   // ----------------- Reset / Save -----------------
//   void resetAll() {
//     recordType = 'PM';
//     amNumber = '';
//     pmNumber = '';
//
//     fdiToothData.clear();
//     teethFindings.clear();
//
//     otherFindings = "";
//     dentitionType = "";
//     ageMin = null;
//     ageMax = null;
//     qualityCheckSignature = "";
//     qualityCheckDate = null;
//
//     upperJawWithTeeth = false;
//     lowerJawWithTeeth = false;
//     upperJawWithoutTeeth = false;
//     lowerJawWithoutTeeth = false;
//     fragments = false;
//     teethOnly = '';
//     otherMaterials = '';
//
//     paDigital = false;
//     paNonDigital = false;
//     bwDigital = false;
//     bwNonDigital = false;
//     opgDigital = false;
//     opgNonDigital = false;
//     ctDigital = false;
//     ctNonDigital = false;
//     otherDigital = false;
//     otherNonDigital = false;
//     photographsDigital = false;
//     photographsNonDigital = false;
//     otherRadiographs = '';
//     uploadedFiles = [];
//
//     conditionOfJaws = '';
//     otherDetails = '';
//
//     placeOfDisaster = '';
//     natureOfDisaster = '';
//     dateOfDisaster = null;
//     gender = '';
//
//     notifyListeners();
//   }
//
//   Map<String, dynamic> toMap() {
//     return {
//       'recordType': recordType,
//       'amNumber': amNumber,
//       'pmNumber': pmNumber,
//       'placeOfDisaster': placeForUi,
//       'natureOfDisaster': natureForUi,
//       'dateOfDisaster': dateOfDisaster?.toIso8601String(),
//       'gender': gender,
//
//       // Ï†ïÍ∑ú Íµ¨Ï°∞ Ï†ÄÏû•
//       'teethFindings': {
//         for (final e in teethFindings.entries) e.key.toString(): e.value.toJson(),
//       },
//
//       // (ÌïòÏúÑ Ìò∏Ìôò) Í∞ÑÎã® Î¨∏ÏûêÏó¥
//       'fdiToothData': {for (final e in fdiToothData.entries) e.key.toString(): e.value},
//
//       'otherFindings': otherFindings,
//       'dentitionType': dentitionType,
//       'ageMin': ageMin,
//       'ageMax': ageMax,
//       'qualityCheckSignature': qualityCheckSignature,
//       'qualityCheckDate': qualityCheckDate?.toIso8601String(),
//
//       'upperJawWithTeeth': upperJawWithTeeth,
//       'lowerJawWithTeeth': lowerJawWithTeeth,
//       'upperJawWithoutTeeth': upperJawWithoutTeeth,
//       'lowerJawWithoutTeeth': lowerJawWithoutTeeth,
//       'fragments': fragments,
//       'teethOnly': teethOnly,
//       'otherMaterials': otherMaterials,
//
//       'paDigital': paDigital,
//       'paNonDigital': paNonDigital,
//       'bwDigital': bwDigital,
//       'bwNonDigital': bwNonDigital,
//       'opgDigital': opgDigital,
//       'opgNonDigital': opgNonDigital,
//       'ctDigital': ctDigital,
//       'ctNonDigital': ctNonDigital,
//       'otherDigital': otherDigital,
//       'otherNonDigital': otherNonDigital,
//       'photographsDigital': photographsDigital,
//       'photographsNonDigital': photographsNonDigital,
//       'otherRadiographs': otherRadiographs,
//       'uploadedFiles': uploadedFiles,
//
//       'conditionOfJaws': conditionOfJaws,
//       'otherDetails': otherDetails,
//     };
//   }
// }

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'dart:collection';                 // ‚Üê Ï∂îÍ∞Ä
import '../data/codes_635.dart';
import '../services/local_store.dart';    // ‚Üê Ï∂îÍ∞Ä (Hive ÎûòÌçº ÏÇ¨Ïö© Ïãú)

import '../models/uploaded_file_meta.dart';

// ‚úÖ ADD: Í≥ÑÏ∏µ ÏΩîÎìú Î°úÎî©ÏùÑ ÏúÑÌïú import
import 'dart:convert';
import 'package:flutter/services.dart' show rootBundle;

import 'package:firebase_core/firebase_core.dart';

import '../schema.dart';

// ‚úÖ ADD: Î∑∞ Î™®Îìú (Ï∂ïÏÜå/ÌôïÎåÄ)
enum ViewMode { zoomOut, zoomIn }

// ‚úÖ ADD: Ï∂ïÏÜåÎ∑∞(DentalFindingsScreen)Îäî Ïù¥ Îëê Ïπ¥ÌÖåÍ≥†Î¶¨Îßå Îã§Î£∏
const spanCategories = <String>{
  'Denture and Orthodontic Appl.',
  'Bridge',
};

// ‚úÖ ADD: Í≥ÑÏ∏µ ÏΩîÎìú ÎÖ∏Îìú
class CodeNode {
  final String code;       // "bridge", "ABU", "UIB", "MTB" ...
  final String label;      // ÌëúÏãúÏö©
  final List<CodeNode> children;
  bool get isLeaf => children.isEmpty;

  CodeNode({required this.code, required this.label, this.children = const []});

  factory CodeNode.fromMap(String code, Map<String, dynamic> m) {
    final Map<String, dynamic> childMap = (m['children'] ?? {}) as Map<String, dynamic>;
    return CodeNode(
      code: code,
      label: (m['label'] ?? code).toString(),
      children: childMap.entries.map((e) => CodeNode.fromMap(e.key, e.value)).toList(),
    );
  }

  Map<String, dynamic> toMap() => {
    'code': code,
    'label': label,
    'children': [for (final c in children) c.toMap()],
  };
}

// ‚úÖ ADD: Ïñ¥Îñ§ Î†àÎ≤®ÏóêÏÑúÎì† ÌôïÏ†ï Í∞ÄÎä•Ìïú ÏÑ†ÌÉù Í≤ΩÎ°ú
class CodeSelection {
  final String category;     // Ïòà: "Bridge" / "Denture and Orthodontic Appl." / Í∏∞ÌÉÄ
  final List<String> path;   // Î£®Ìä∏‚ÜíÏÑ†ÌÉù ÎÖ∏Îìú: ["bridge","ABU","UIB","MTB"] Ï§ë Ïñ¥ÎîîÏÑúÎì† Ï¢ÖÎ£å Í∞ÄÎä•

  const CodeSelection({required this.category, required this.path});

  String get selected => path.isEmpty ? "" : path.last;
  int get depth => path.length;

  Map<String, dynamic> toMap() => {
    "category": category,
    "path": path,
    "selected": selected,
    "depth": depth,
  };

  factory CodeSelection.fromMap(Map<String, dynamic> m) =>
      CodeSelection(
        category: (m["category"] ?? "").toString(),
        path: List<String>.from((m["path"] as List?) ?? const []),
      );
}

/// 5Î©¥ ÌÇ§ (Ï§ëÏïô O, ÏúÑ L, ÏïÑÎûò B, Ï¢å/Ïö∞Îäî M/D)
const List<String> kToothSurfaces = ['O', 'M', 'D', 'L', 'B'];

// ===== Ïä§Ìå¨ Î™®Îç∏ =====
enum DentalSpanType { dentureOrtho, bridge }

class DentalSpan {
  final String id;
  final DentalSpanType type;
  final Set<int> teeth;     // Ïù¥ Ïä§Ìå¨Ïóê ÏÜçÌïú Î™®Îì† FDI
  final Set<int> abutments; // bridge Ï†ÑÏö©
  final Set<int> pontics;   // bridge Ï†ÑÏö©
  final String? code;       // denture/ortho ÏΩîÎìú(Ïòà: CLA, FUD ...)

  DentalSpan({
    required this.id,
    required this.type,
    required Set<int> teeth,
    Set<int>? abutments,
    Set<int>? pontics,
    this.code,
  })  : teeth = {...teeth},
        abutments = {...(abutments ?? const <int>{})},
        pontics = {...(pontics ?? const <int>{})};

  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type.name,
    'teeth': teeth.toList(),
    'abutments': abutments.toList(),
    'pontics': pontics.toList(),
    'code': code,
  };

  factory DentalSpan.fromJson(Map<String, dynamic> j) => DentalSpan(
    id: (j['id'] ?? '').toString(),
    type: DentalSpanType.values.firstWhere(
          (e) => e.name == (j['type'] as String? ?? 'dentureOrtho'),
      orElse: () => DentalSpanType.dentureOrtho,
    ),
    teeth: Set<int>.from(
      ((j['teeth'] as List?) ?? const [])
          .map((e) => int.parse(e.toString())),
    ),
    abutments: Set<int>.from(
      ((j['abutments'] as List?) ?? const [])
          .map((e) => int.parse(e.toString())),
    ),
    pontics: Set<int>.from(
      ((j['pontics'] as List?) ?? const [])
          .map((e) => int.parse(e.toString())),
    ),
    code: j['code'] as String?,
  );
}

// ===== 635 Specific Data =====
class SpecificData {
  SpecificData();
  // Ï†ÑÏó≠ ÏΩîÎìú: bite/crown/root/status/position/crown pathology
  final Map<String, List<String>> global = {
    'bite': <String>[],
    'crown': <String>[],
    'root': <String>[],
    'status': <String>[],
    'position': <String>[],
    'crown pathology': <String>[],
  };

  // ÌëúÎ©¥ ÏΩîÎìú: O/M/D/L/B √ó (fillings/periodontium)
  final Map<String, Map<String, List<String>>> surface = {
    for (final s in kToothSurfaces)
      s: {
        'fillings': <String>[],
        'periodontium': <String>[],
      }
  };

  String? toothNote;                        // ÏπòÏïÑ Ï†ÑÏó≠ ÏûêÏó∞Ïñ¥
  final Map<String, String> surfaceNote = <String, String>{}; // ÌëúÎ©¥ ÏûêÏó∞Ïñ¥

  Map<String, dynamic> toJson() => {
    'global': global,
    'surface': surface,
    'toothNote': toothNote,
    'surfaceNote': surfaceNote,
  };

  factory SpecificData.fromJson(Map<String, dynamic> j) {
    final x = SpecificData();
    final g = (j['global'] as Map?) ?? {};
    for (final k in x.global.keys) {
      x.global[k] = List<String>.from((g[k] as List?) ?? const []);
    }
    final sv = (j['surface'] as Map?) ?? {};
    for (final s in kToothSurfaces) {
      final m = (sv[s] as Map?) ?? {};
      x.surface[s]!['fillings']     = List<String>.from((m['fillings'] as List?) ?? const []);
      x.surface[s]!['periodontium'] = List<String>.from((m['periodontium'] as List?) ?? const []);
    }
    x.toothNote = j['toothNote'] as String?;
    final sn = (j['surfaceNote'] as Map?) ?? {};
    x.surfaceNote.addAll(sn.map((k, v) => MapEntry(k.toString(), v.toString())));
    return x;
  }
}

class DentalDataProvider extends ChangeNotifier {

  DentalDataProvider({bool listenIncidentLock = false}) {
    if (listenIncidentLock) startIncidentLockListener();
  }

  // ‚úÖ ADD: Interpol Í≥ÑÏ∏µ ÏΩîÎìú Ìä∏Î¶¨
  final Map<String, CodeNode> _codeRoots = {};   // Ïπ¥ÌÖåÍ≥†Î¶¨ ‚Üí Î£®Ìä∏ ÎÖ∏Îìú
  Set<String> _allCategories = {};               // Î°úÎî©Îêú Ï†ÑÏ≤¥ Ïπ¥ÌÖåÍ≥†Î¶¨

  bool get hasCodeTree => _codeRoots.isNotEmpty;

  /// Ïï± ÏãúÏûë/ÏµúÏ¥à ÏßÑÏûÖ Ïãú Ìïú Î≤àÎßå Î°úÎìú
  Future<void> loadCodeTreeOnce() async {
    if (_codeRoots.isNotEmpty) return;

    final raw = await rootBundle.loadString('lib/data/prosthesis_tree.json');
    final Map<String, dynamic> jsonMap = jsonDecode(raw);
    _codeRoots.clear();
    _allCategories = jsonMap.keys.toSet();
    jsonMap.forEach((cat, body) {
      final children = (body as Map<String, dynamic>)
          .map((k, v) => MapEntry(k, CodeNode.fromMap(k, v)));
      _codeRoots[cat] = CodeNode(
        code: cat,
        label: cat,
        children: children.values.toList(),
      );
    });
    notifyListeners();
  }

  /// Î∑∞Ïóê Îî∞Îùº ÎÖ∏Ï∂úÌï† Ïπ¥ÌÖåÍ≥†Î¶¨ Î¶¨Ïä§Ìä∏
  List<String> availableCategories(ViewMode mode) {
    if (_codeRoots.isEmpty) return const [];
    if (mode == ViewMode.zoomOut) {
      // Ï∂ïÏÜåÎ∑∞: Ïä§Ìå¨ Ï†ÑÏö© 2Í∞ú Ïπ¥ÌÖåÍ≥†Î¶¨Îßå
      return _allCategories.where(spanCategories.contains).toList()..sort();
    } else {
      // ÌôïÎåÄÎ∑∞: ÎÇòÎ®∏ÏßÄ Ï†ÑÏ≤¥ Ïπ¥ÌÖåÍ≥†Î¶¨
      return _allCategories.where((c) => !spanCategories.contains(c)).toList()..sort();
    }
  }

// ---------- Ìä∏Î¶¨ ÌÉêÏÉâ/Í≤ÄÏ¶ù ----------
  CodeNode? _findNode(String category, List<String> path) {
    final root = _codeRoots[category];
    if (root == null) return null;
    CodeNode cur = root;
    for (final step in path) {
      final idx = cur.children.indexWhere((n) => n.code.toLowerCase() == step.toLowerCase());
      if (idx < 0) return null;
      cur = cur.children[idx];
    }
    return cur;
  }

  List<CodeNode> listChildren(String category, List<String> path) =>
      _findNode(category, path)?.children ?? const [];

  bool isValidSelection(String category, List<String> path) =>
      _findNode(category, path) != null;

// ---------- ÏÑ†ÌÉù ÏÉÅÌÉú(ÏÑ†ÌÉù ÏÇ¨Ìï≠) ----------
  CodeSelection? currentSelectionCompact; // Ï∂ïÏÜåÎ∑∞(DentalFindingsScreen)
  CodeSelection? currentSelectionZoom;    // ÌôïÎåÄÎ∑∞(QuadrantZoomScreen)

  void setSelectionFor(ViewMode mode, CodeSelection? sel) {
    if (mode == ViewMode.zoomOut) {
      currentSelectionCompact = sel;
    } else {
      currentSelectionZoom = sel;
    }
    notifyListeners();
  }

  // 635 Specific Data (Ïù∏Ïä§ÌÑ¥Ïä§ Î≥¥Í¥Ä)
  final Map<int, SpecificData> _spec635 = <int, SpecificData>{};
  final List<DentalSpan> _spans = <DentalSpan>[];                 // ‚Üê Ï∂îÍ∞Ä
  UnmodifiableListView<DentalSpan> get spans => UnmodifiableListView(_spans); // ‚Üê Ï∂îÍ∞Ä

  Timer? _saveDebounce;                                           // ‚Üê Ï∂îÍ∞Ä(ÏûêÎèô Ï†ÄÏû• ÎîîÎ∞îÏö¥Ïä§)
  static int _idSeed = 0;                                         // ‚Üê Ï∂îÍ∞Ä

  void _scheduleAutosave() {                                       // ‚Üê Ï∂îÍ∞Ä
    _saveDebounce?.cancel();
    _saveDebounce = Timer(const Duration(milliseconds: 300), () async {
      await LocalStore.saveDentalState(toMap());
    });
  }

  void _markDirty() {                                              // ‚Üê Ï∂îÍ∞Ä
    _scheduleAutosave();
    notifyListeners();
  }

  /// ÏùΩÍ∏∞ Ï†ÑÏö© getter (ÏóÜÏúºÎ©¥ null)
  SpecificData? getSpecRead(int fdi) => _spec635[fdi];

  /// Ïì∞Í∏∞Ïö©: ÏóÜÏúºÎ©¥ ÏÉùÏÑ±Ìï¥ÏÑú Î∞òÌôò
  SpecificData ensureSpec(int fdi) =>
      _spec635.putIfAbsent(fdi, () => SpecificData());

  // Ï†ÑÏó≠ ÏΩîÎìú ÌÜ†Í∏Ä
  void toggleGlobalCode(int fdi, String group, String code) {
    final s = ensureSpec(fdi).global[group];
    if (s == null) return;
    if (s.contains(code)) { s.remove(code); } else { s.add(code); }
    notifyListeners();
  }

  // ÌëúÎ©¥ ÏΩîÎìú ÌÜ†Í∏Ä
  void toggleSurfaceCode(int fdi, String surface, String group, String code) {
    if (!kToothSurfaces.contains(surface)) return;
    final s = ensureSpec(fdi).surface[surface]?[group];
    if (s == null) return;
    if (s.contains(code)) { s.remove(code); } else { s.add(code); }
    notifyListeners();
  }

  // ÏûêÏó∞Ïñ¥ Î©îÎ™®
  void setToothNote635(int fdi, String? note) {
    ensureSpec(fdi).toothNote = (note?.trim().isEmpty ?? true) ? null : note!.trim();
    notifyListeners();
  }

  void setSurfaceNote635(int fdi, String surface, String note) {
    if (!kToothSurfaces.contains(surface)) return;
    ensureSpec(fdi).surfaceNote[surface] = note;
    notifyListeners();
  }

  // ÌëúÎ©¥ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤¥ ÏÇ≠Ï†ú (ÏΩîÎìú+Î©îÎ™®)
  void clearSurface635(int fdi, String surface) {
    if (!kToothSurfaces.contains(surface)) return;
    final s = _spec635[fdi];
    if (s == null) return;
    s.surface[surface]?['fillings']?.clear();
    s.surface[surface]?['periodontium']?.clear();
    s.surfaceNote.remove(surface);
    notifyListeners();
  }

  void clearGlobalAll635(int fdi) {
    final spec = getSpecRead(fdi);
    if (spec == null) return;

    // ‚úÖ Ï†ÑÏó≠ Í∑∏Î£π Ï¥àÍ∏∞Ìôî
    for (final g in k635GlobalCodes.keys) {
      spec.global[g] = <String>[];   // Ï†ÑÏó≠ ÏΩîÎìú Î™®Îëê ÎπÑÏõÄ
    }

    // ‚úÖ Ï†ÑÏó≠ Î©îÎ™® Ï¥àÍ∏∞Ìôî
    spec.toothNote = '';

    notifyListeners();
  }

  // ----------------- Record / Incident lock -----------------
  String recordType = 'PM';
  String amNumber = '';
  String pmNumber = '';

  bool incidentLockEnabled = false;
  String lockedPlace = '';
  String lockedNature = '';
  String get placeForUi =>
      (incidentLockEnabled && lockedPlace.isNotEmpty) ? lockedPlace : placeOfDisaster;
  String get natureForUi =>
      (incidentLockEnabled && lockedNature.isNotEmpty) ? lockedNature : natureOfDisaster;

  DocumentReference<Map<String, dynamic>>? _lockDoc;
  StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>? _lockSub;

  bool get _firebaseReady => Firebase.apps.isNotEmpty;

  /// Firebase init ÏôÑÎ£å ÌõÑÏóêÎßå Ìò∏Ï∂ú (Ï§ëÎ≥µ Ìò∏Ï∂ú ÏïàÏ†Ñ)
  void startIncidentLockListener() {
    if (_lockSub != null) return;          // Ïù¥ÎØ∏ Î∂ôÏñ¥ÏûàÏùå
    if (!_firebaseReady) return;            // ÏïÑÏßÅ Firebase Ï¥àÍ∏∞Ìôî Ï†Ñ

    _lockDoc ??= FirebaseFirestore.instance
        .collection('config')
        .doc('incidentLock');

    _lockSub = _lockDoc!.snapshots().listen(
          (snap) {
        if (!snap.exists) return; // Ï¥àÍ∏∞Ïóî ÏóÜÏùÑ Ïàò ÏûàÏùå
        final d = snap.data();
        if (d == null) return;
        _withoutAutosave(() {
          incidentLockEnabled = (d['enabled'] ?? false) as bool;
          lockedPlace = (d['place'] ?? '') as String;
          lockedNature = (d['nature'] ?? '') as String;
          super.notifyListeners(); // Ï†ÄÏû• Ïïà Ìï®
        });
      },
      onError: (e, [st]) {
        debugPrint('incidentLock listen error: $e');
      },
    );
  }

  void stopIncidentLockListener() {
    _lockSub?.cancel();
    _lockSub = null;
  }

  Future<void> setIncidentLockRemote({
    required bool enabled,
    required String place,
    required String nature,
  }) async {
    try {
      if (!_firebaseReady) {
        throw StateError('Firebase is not initialized yet.');
      }
      if (enabled && (place.isEmpty || nature.isEmpty)) {
        throw ArgumentError('Place/Nature required to enable incident lock.');
      }
      _lockDoc ??= FirebaseFirestore.instance
          .collection('config')
          .doc('incidentLock');

      await _lockDoc!.set(
        {
          'enabled': enabled,
          'place': place,
          'nature': nature,
          'updatedAt': FieldValue.serverTimestamp(),
          'byUid': FirebaseAuth.instance.currentUser?.uid,
        },
        SetOptions(merge: true),
      );
    } on FirebaseException catch (e) {
      debugPrint('setIncidentLockRemote failed: ${e.code} ${e.message}');
      rethrow;
    }
  }

  @override
  void dispose() {
    stopIncidentLockListener();  // ‚úÖ Íµ¨ÎèÖ Ï†ïÎ¶¨
    _saveDebounce?.cancel();
    super.dispose();
  }

  // ----------------- Odontogram (STEP 2 Ï†ÑÏö© Í≤ΩÎüâ ÏÉÅÌÉú) -----------------

  /// (ÌïòÏúÑ Ìò∏Ìôò) Í∞ÑÎã® Î¨∏ÏûêÏó¥ Î©îÎ™® ‚Äî Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
  final Map<int, Map<String, dynamic>> fdiToothData = <int, Map<String, dynamic>>{};

  /// ÌëúÎ©¥ ÏÑ†ÌÉù ÌÜ†Í∏Ä ÏÉÅÌÉúÎßå Í∞ÑÎã® Î≥¥Í¥Ä (STEP 1/2)
  final Map<int, Set<String>> _selectedSurfaces = <int, Set<String>>{};

  Set<String> getSelectedSurfaces(int fdi) => _selectedSurfaces[fdi] ?? <String>{};

  void toggleSurface(int fdi, String surfaceKey) {
    if (!kToothSurfaces.contains(surfaceKey)) return;
    final s = _selectedSurfaces.putIfAbsent(fdi, () => <String>{});
    if (s.contains(surfaceKey)) {
      s.remove(surfaceKey);
    } else {
      s.add(surfaceKey);
    }
    notifyListeners();
  }

  void clearSurfaces(int fdi) {
    final s = _selectedSurfaces[fdi];
    if (s == null) return;
    s.clear();
    notifyListeners();
  }

  // ----------------- STEP 2: Denture/Bridge Ïä§Ìå¨ -----------------

  String _randId() => 'sp_${DateTime.now().microsecondsSinceEpoch}_${_idSeed++}';

  List<DentalSpan> spansIntersecting(Iterable<int> fdis) {
    final set = fdis.toSet();
    return _spans.where((sp) => sp.teeth.any(set.contains)).toList();
  }

  bool _isUpperFdi(int fdi) {
    final q = fdi ~/ 10;
    return q == 1 || q == 2 || q == 5 || q == 6;
  }

  bool _allSameArch(Iterable<int> fdis) {
    bool? first;
    for (final f in fdis) {
      final up = _isUpperFdi(f);
      first ??= up;
      if (up != first) return false;
    }
    return true;
  }

  bool _hasTypeConflictInternal(Iterable<int> teeth, DentalSpanType creating) {
    final set = teeth.toSet();
    return _spans.any((sp) => sp.type != creating && sp.teeth.any(set.contains));
  }

  void addDentureSpan(List<int> selectedFdi, {String? code}) {
    if (selectedFdi.isEmpty) return;
    if (!_allSameArch(selectedFdi)) {
      debugPrint('‚ùå ÏÉÅ/ÌïòÏïÖ ÌòºÌï© Ïä§Ìå¨ Í∏àÏßÄ');
      return;
    }
    // ‚ñº Ï∂îÍ∞Ä: BridgeÏôÄ Ï∂©Îèå Î∞©ÏßÄ
    if (_hasTypeConflictInternal(selectedFdi, DentalSpanType.dentureOrtho)) {
      debugPrint('‚ùå Denture/Ortho ÏÉùÏÑ± Ïã§Ìå®: Ïù¥ÎØ∏ Bridge Ïä§Ìå¨Í≥º Í≤πÏπ©ÎãàÎã§.');
      return;
    }

    _spans.add(DentalSpan(
      id: _randId(),
      type: DentalSpanType.dentureOrtho,
      teeth: Set<int>.from(selectedFdi),
      code: code,
    ));
    _markDirty(); // notifyListeners() ÎåÄÏã†
  }

  void addBridgeSpan({
    required List<int> selectedFdi,
    required Set<int> abutments,
    required Set<int> pontics,
    String? code,
  }) {
    if (selectedFdi.isEmpty || abutments.isEmpty || pontics.isEmpty) return;

    // Ï†ÑÏ≤¥ ÏπòÏïÑ(ÏßÄÎåÄÏπò+pontic Ìè¨Ìï®) Í∞ôÏùÄ ÏïÖÍ∂ÅÎßå ÌóàÏö©
    final union = {...selectedFdi, ...abutments, ...pontics};
    if (!_allSameArch(union)) {
      debugPrint('‚ùå ÏÉÅ/ÌïòÏïÖ ÌòºÌï© Î∏åÎ¶¨ÏßÄ Í∏àÏßÄ');
      return;
    }

    // ‚ñº Ï∂îÍ∞Ä: DentureÏôÄ Ï∂©Îèå Î∞©ÏßÄ
    if (_hasTypeConflictInternal(union, DentalSpanType.bridge)) {
      debugPrint('‚ùå Bridge ÏÉùÏÑ± Ïã§Ìå®: Ïù¥ÎØ∏ Denture/Ortho Ïä§Ìå¨Í≥º Í≤πÏπ©ÎãàÎã§.');
      return;
    }

    _spans.add(DentalSpan(
      id: _randId(),
      type: DentalSpanType.bridge,
      teeth: Set<int>.from(selectedFdi),
      abutments: abutments,
      pontics: pontics,
      code: code,
    ));
    _markDirty(); // notifyListeners() ÎåÄÏã†
  }

  void removeSpan(String id) {
    _spans.removeWhere((e) => e.id == id);
    _markDirty(); // notifyListeners() ÎåÄÏã†
  }

  /// ÏÑ†ÌÉùÎêú ÏπòÏïÑÏôÄ ÍµêÏßëÌï©Ïù¥ ÏûàÎäî Ïä§Ìå¨ ÏùºÍ¥Ñ ÏÇ≠Ï†ú (Ìà¥Î∞îÏùò 'Ïä§Ìå¨ ÏÇ≠Ï†ú'ÏóêÏÑú ÏÇ¨Ïö©)
  int removeSpansIntersecting(Set<int> targets,
      {bool removeDenture = true, bool removeBridge = true}) {
    final before = _spans.length;
    _spans.removeWhere((sp) {
      final hit = sp.teeth.any(targets.contains);
      if (!hit) return false;
      if (sp.type == DentalSpanType.dentureOrtho && !removeDenture) return false;
      if (sp.type == DentalSpanType.bridge && !removeBridge) return false;
      return true;
    });
    final removed = before - _spans.length;
    if (removed > 0) _markDirty(); // notifyListeners() ÎåÄÏã†
    return removed;
  }

// 635 Ìïú Ï§Ñ ÌîÑÎ¶¨Î∑∞
  String build635Line(int fdi) {
    final s = _spec635[fdi];
    if (s == null) return '';
    final out = <String>[];
    for (final surf in kToothSurfaces) {
      for (final grp in const ['fillings', 'periodontium']) {
        final list = s.surface[surf]![grp]!;
        if (list.isNotEmpty) out.add('${list.join(",")}($surf)');
      }
    }
    for (final g in const ['bite','crown','root','status','position','crown pathology']) {
      final list = s.global[g]!;
      if (list.isNotEmpty) out.add(list.join(','));
    }
    if (s.toothNote != null && s.toothNote!.isNotEmpty) out.add('note:${s.toothNote}');
    return out.join(' ¬∑ ');
  }

  // Ï†ÑÏ≤¥ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
  Map<String, dynamic> exportSpecAll() => {
    for (final e in _spec635.entries) e.key.toString(): e.value.toJson(),
  };

  // ----------------- (ÌïòÏúÑ Ìò∏Ìôò) Í∞ÑÎã® Î¨∏ÏûêÏó¥ Î©îÎ™® Ï°∞Ïûë -----------------
  void setToothDetail(int tooth, String detail) {
    fdiToothData[tooth] = {'detail': detail};
    notifyListeners();
  }

  void bulkSetToothDetail(Iterable<int> teeth, String detail) {
    for (final t in teeth) {
      fdiToothData[t] = {'detail': detail};
    }
    notifyListeners();
  }

  void clearToothDetail(int tooth) {
    fdiToothData.remove(tooth);
    notifyListeners();
  }

  // ----------------- ÎÇòÎ®∏ÏßÄ Ìèº ÌïÑÎìú -----------------
  String otherFindings = "";
  String dentitionType = "";
  int? ageMin;
  int? ageMax;
  String qualityCheckSignature = "";
  DateTime? qualityCheckDate;

  // 610 Materials Available
  bool upperJawWithTeeth = false;
  bool lowerJawWithTeeth = false;
  bool upperJawWithoutTeeth = false;
  bool lowerJawWithoutTeeth = false;
  bool fragments = false;
  String teethOnly = '';
  String otherMaterials = '';

  // Radiographs
  bool paDigital = false;
  bool paNonDigital = false;
  bool bwDigital = false;
  bool bwNonDigital = false;
  bool opgDigital = false;
  bool opgNonDigital = false;
  bool ctDigital = false;
  bool ctNonDigital = false;
  bool otherDigital = false;
  bool otherNonDigital = false;
  bool photographsDigital = false;
  bool photographsNonDigital = false;
  String otherRadiographs = '';
  List<String> uploadedFiles = [];
  final Map<String, UploadedFileMeta> uploadedFilesMeta = <String, UploadedFileMeta>{};

  String conditionOfJaws = '';
  String otherDetails = '';

  // RecordScreen ÏõêÎ≥∏ ÏûÖÎ†•
  String placeOfDisaster = '';
  String natureOfDisaster = '';
  DateTime? dateOfDisaster;
  String gender = '';

  // ----------------- Updaters -----------------
  void updateRecordType(String type) {
    if (type != 'PM' && type != 'AM') return;
    if (recordType == type) return;
    recordType = type;
    notifyListeners();
  }

  void updateAmNumber(String value) {
    if (amNumber == value) return;
    amNumber = value;
    notifyListeners();
  }

  void updatePmNumber(String pm) {
    if (pmNumber == pm) return;
    pmNumber = pm;
    notifyListeners();
  }

  void updatePlace(String place) {
    if (incidentLockEnabled) return;
    placeOfDisaster = place;
    notifyListeners();
  }

  void updateNature(String nature) {
    if (incidentLockEnabled) return;
    natureOfDisaster = nature;
    notifyListeners();
  }

  void updateDisasterDate(DateTime date) {
    dateOfDisaster = date;
    notifyListeners();
  }

  void updateGender(String selectedGender) {
    gender = selectedGender;
    notifyListeners();
  }

  void updateOtherFindings(String value) {
    otherFindings = value;
    notifyListeners();
  }

  void updateDentitionType(String type) {
    dentitionType = type;
    notifyListeners();
  }

  void updateAgeMin(int? value) {
    ageMin = value;
    notifyListeners();
  }

  void updateAgeMax(int? value) {
    ageMax = value;
    notifyListeners();
  }

  void updateQualitySignature(String value) {
    qualityCheckSignature = value;
    notifyListeners();
  }

  void updateQualityDate(DateTime date) {
    qualityCheckDate = date;
    notifyListeners();
  }

  void setMaterialsAvailable({
    required bool upperWith,
    required bool lowerWith,
    required bool upperWithout,
    required bool lowerWithout,
    required bool hasFragments,
    required String teethText,
    required String otherText,
  }) {
    upperJawWithTeeth = upperWith;
    lowerJawWithTeeth = lowerWith;
    upperJawWithoutTeeth = upperWithout;
    lowerJawWithoutTeeth = lowerWithout;
    fragments = hasFragments;
    teethOnly = teethText;
    otherMaterials = otherText;
    notifyListeners();
  }

  void setEachMaterial({
    bool? upperWith,
    bool? lowerWith,
    bool? upperWithout,
    bool? lowerWithout,
    bool? hasFragments,
    String? teethText,
    String? otherText,
  }) {
    if (upperWith != null) upperJawWithTeeth = upperWith;
    if (lowerWith != null) lowerJawWithTeeth = lowerWith;
    if (upperWithout != null) upperJawWithoutTeeth = upperWithout;
    if (lowerWithout != null) lowerJawWithoutTeeth = lowerWithout;
    if (hasFragments != null) fragments = hasFragments;
    if (teethText != null) teethOnly = teethText;
    if (otherText != null) otherMaterials = otherText;
    notifyListeners();
  }

  void setDentalImages({
    bool? paD,
    bool? paND,
    bool? bwD,
    bool? bwND,
    bool? opgD,
    bool? opgND,
    bool? ctD,
    bool? ctND,
    bool? otherD,
    bool? otherND,
    bool? photoD,
    bool? photoND,
    String? otherRadio,
    List<String>? uploads,
  }) {
    if (paD != null) paDigital = paD;
    if (paND != null) paNonDigital = paND;
    if (bwD != null) bwDigital = bwD;
    if (bwND != null) bwNonDigital = bwND;
    if (opgD != null) opgDigital = opgD;
    if (opgND != null) opgNonDigital = opgND;
    if (ctD != null) ctDigital = ctD;
    if (ctND != null) ctNonDigital = ctND;
    if (otherD != null) otherDigital = otherD;
    if (otherND != null) otherNonDigital = otherND;
    if (photoD != null) photographsDigital = photoD;
    if (photoND != null) photographsNonDigital = photoND;
    if (otherRadio != null) otherRadiographs = otherRadio;
    if (uploads != null) uploadedFiles = uploads;
    notifyListeners();
  }

  void setConditionOfJaws(String value) {
    conditionOfJaws = value;
    notifyListeners();
  }

  void setOtherDetails(String value) {
    otherDetails = value;
    notifyListeners();
  }

  void setFdiToothData(Map<int, Map<String, String>> newData) {
    fdiToothData.clear();
    fdiToothData.addAll(newData);
    notifyListeners();
  }

  void addUploadedFile(String fileUrl) {
    uploadedFiles.add(fileUrl);
    notifyListeners();
  }

  void removeUploadedFile(String fileUrl) {
    uploadedFiles.remove(fileUrl);
    notifyListeners();
  }

  // Î©îÌÉÄ upsert
  void setUploadedFileMeta(UploadedFileMeta meta) {
    uploadedFilesMeta[meta.url] = meta;
    notifyListeners();
  }

// Î©îÌÉÄ ÏÇ≠Ï†ú
  void removeUploadedFileMeta(String url) {
    uploadedFilesMeta.remove(url);
    notifyListeners();
  }


  // ----------------- Reset / Save -----------------
  Map<String, dynamic> toMap() {

    final effectivePlace  = (incidentLockEnabled && lockedPlace.isNotEmpty)
        ? lockedPlace : placeOfDisaster;
    final effectiveNature = (incidentLockEnabled && lockedNature.isNotEmpty)
        ? lockedNature : natureOfDisaster;

    return {

      '_v': Schema.current,

      'recordType': recordType,
      'amNumber': amNumber,
      'pmNumber': pmNumber,
      'placeOfDisaster': effectivePlace,   // ‚Üê Ïä§ÌÉ¨Ìïë
      'placeNorm': (effectivePlace).trim().toLowerCase(),
      'natureOfDisaster': effectiveNature, // ‚Üê Ïä§ÌÉ¨Ìïë
      'dateOfDisaster': dateOfDisaster?.toIso8601String(),
      'gender': gender,

      'fdiToothData': {
        for (final e in fdiToothData.entries) e.key.toString(): e.value
      },

      'spans': _spans.map((e) => e.toJson()).toList(),
      'spec635': {
        for (final e in _spec635.entries) e.key.toString(): e.value.toJson()
      },

      'otherFindings': otherFindings,
      'dentitionType': dentitionType,
      'ageMin': ageMin,
      'ageMax': ageMax,
      'qualityCheckSignature': qualityCheckSignature,
      'qualityCheckDate': qualityCheckDate?.toIso8601String(),

      'upperJawWithTeeth': upperJawWithTeeth,
      'lowerJawWithTeeth': lowerJawWithTeeth,
      'upperJawWithoutTeeth': upperJawWithoutTeeth,
      'lowerJawWithoutTeeth': lowerJawWithoutTeeth,
      'fragments': fragments,
      'teethOnly': teethOnly,
      'otherMaterials': otherMaterials,

      'paDigital': paDigital,
      'paNonDigital': paNonDigital,
      'bwDigital': bwDigital,
      'bwNonDigital': bwNonDigital,
      'opgDigital': opgDigital,
      'opgNonDigital': opgNonDigital,
      'ctDigital': ctDigital,
      'ctNonDigital': ctNonDigital,
      'otherDigital': otherDigital,
      'otherNonDigital': otherNonDigital,
      'photographsDigital': photographsDigital,
      'photographsNonDigital': photographsNonDigital,
      'otherRadiographs': otherRadiographs,
      'uploadedFiles': uploadedFiles,
      'uploadedMeta': {
        for (final e in uploadedFilesMeta.entries) e.key: e.value.toMap(),
      },

      'conditionOfJaws': conditionOfJaws,
      'otherDetails': otherDetails,

      // ‚úÖ PATCH: toMap() Î∞òÌôò ÎßµÏóê Ï∂îÍ∞Ä
      'codeSelectionCompact': currentSelectionCompact?.toMap(),
      'codeSelectionZoom': currentSelectionZoom?.toMap(),
    };
  }

  void fromMap(Map<String, dynamic> m) {

    final ver = (m['_v'] is int) ? m['_v'] as int : 1;

    if (ver < Schema.current) {
      // ‚úÖ Ïó¨Í∏∞ÏÑú Î≤ÑÏ†ÑÏóê Îî∞Î•∏ Î≥ÄÌôò/Î≥¥Ï†ï Î°úÏßÅ Ï∂îÍ∞Ä Í∞ÄÎä•
      // Ïòà: if (ver < 2) { m['codeSelectionCompact'] ??= null; }
    }

    // Í∏∞Î≥∏Í∞í Ï≤òÎ¶¨ Ïú†Ìã∏
    T _get<T>(String k, T fallback) {
      final v = m[k];
      return (v is T) ? v : fallback;
    }

    recordType = _get<String>('recordType', 'PM');
    amNumber = _get<String>('amNumber', '');
    pmNumber = _get<String>('pmNumber', '');
    placeOfDisaster = _get<String>('placeOfDisaster', '');
    natureOfDisaster = _get<String>('natureOfDisaster', '');
    final dateStr = m['dateOfDisaster'] as String?;
    dateOfDisaster = (dateStr == null || dateStr.isEmpty) ? null : DateTime.tryParse(dateStr);
    gender = _get<String>('gender', '');

    // ÌïòÏúÑ Ìò∏Ìôò fdiToothData
    fdiToothData
      ..clear()
      ..addAll(((m['fdiToothData'] as Map?) ?? const {}).map(
            (k, v) => MapEntry(int.parse(k.toString()), Map<String, dynamic>.from(v as Map)),
      ));

    // spec635
    _spec635
      ..clear()
      ..addAll(((m['spec635'] as Map?) ?? const {}).map(
            (k, v) => MapEntry(int.parse(k.toString()), SpecificData.fromJson(Map<String, dynamic>.from(v as Map))),
      ));

    // spans
    _spans
      ..clear()
      ..addAll(((m['spans'] as List?) ?? const [])
          .whereType<Map>()
          .map((e) => DentalSpan.fromJson(e.map((k, v) => MapEntry(k.toString(), v)))));

    otherFindings = _get<String>('otherFindings', '');
    dentitionType = _get<String>('dentitionType', '');
    ageMin = m['ageMin'] is int ? m['ageMin'] as int : null;
    ageMax = m['ageMax'] is int ? m['ageMax'] as int : null;
    qualityCheckSignature = _get<String>('qualityCheckSignature', '');
    final qDateStr = m['qualityCheckDate'] as String?;
    qualityCheckDate = (qDateStr == null || qDateStr.isEmpty) ? null : DateTime.tryParse(qDateStr);

    upperJawWithTeeth    = _get<bool>('upperJawWithTeeth', false);
    lowerJawWithTeeth    = _get<bool>('lowerJawWithTeeth', false);
    upperJawWithoutTeeth = _get<bool>('upperJawWithoutTeeth', false);
    lowerJawWithoutTeeth = _get<bool>('lowerJawWithoutTeeth', false);
    fragments            = _get<bool>('fragments', false);
    teethOnly            = _get<String>('teethOnly', '');
    otherMaterials       = _get<String>('otherMaterials', '');

    paDigital       = _get<bool>('paDigital', false);
    paNonDigital    = _get<bool>('paNonDigital', false);
    bwDigital       = _get<bool>('bwDigital', false);
    bwNonDigital    = _get<bool>('bwNonDigital', false);
    opgDigital      = _get<bool>('opgDigital', false);
    opgNonDigital   = _get<bool>('opgNonDigital', false);
    ctDigital       = _get<bool>('ctDigital', false);
    ctNonDigital    = _get<bool>('ctNonDigital', false);
    otherDigital    = _get<bool>('otherDigital', false);
    otherNonDigital = _get<bool>('otherNonDigital', false);
    photographsDigital    = _get<bool>('photographsDigital', false);
    photographsNonDigital = _get<bool>('photographsNonDigital', false);
    otherRadiographs      = _get<String>('otherRadiographs', '');
    uploadedFiles         = List<String>.from((m['uploadedFiles'] as List?) ?? const []);

    // ‚úÖ Î©îÌÉÄ (ÏóÜÏñ¥ÎèÑ ÏïàÏ†Ñ)
    final metaMap = (m['uploadedMeta'] as Map?) ?? const {};
    uploadedFilesMeta
      ..clear()
      ..addAll(metaMap.map((k, v) => MapEntry(
        k.toString(),
        UploadedFileMeta.fromMap(Map<String, dynamic>.from(v as Map)),
      )));

    conditionOfJaws = _get<String>('conditionOfJaws', '');
    otherDetails    = _get<String>('otherDetails', '');

    _validateSpanConflicts();

    // ‚úÖ PATCH: fromMap()Ïóê Ï∂îÍ∞Ä (ÏÑ†ÌÉù ÏÉÅÌÉú Î≥µÏõê)
    final csc = m['codeSelectionCompact'];
    currentSelectionCompact = (csc is Map) ? CodeSelection.fromMap(csc.map((k,v)=>MapEntry(k.toString(), v))) : null;

    final csz = m['codeSelectionZoom'];
    currentSelectionZoom = (csz is Map) ? CodeSelection.fromMap(csz.map((k,v)=>MapEntry(k.toString(), v))) : null;
  }

  Future<void> hydrate() async {
    final data = LocalStore.loadDentalState();
    if (data != null) {
      _withoutAutosave(() {
        fromMap(data);
        super.notifyListeners(); // ‚Üê Ïó¨Í∏∞ÏÑúÎäî Ï†ÄÏû• Ïïà Ìï®
      });
    }
  }

  Future<void> resetAll() async {
    _withoutAutosave(() {
    recordType = 'PM';
    amNumber = '';
    pmNumber = '';

    fdiToothData.clear();
    _selectedSurfaces.clear();
    _spans.clear();

    otherFindings = "";
    dentitionType = "";
    ageMin = null;
    ageMax = null;
    qualityCheckSignature = "";
    qualityCheckDate = null;

    upperJawWithTeeth = false;
    lowerJawWithTeeth = false;
    upperJawWithoutTeeth = false;
    lowerJawWithoutTeeth = false;
    fragments = false;
    teethOnly = '';
    otherMaterials = '';

    paDigital = false;
    paNonDigital = false;
    bwDigital = false;
    bwNonDigital = false;
    opgDigital = false;
    opgNonDigital = false;
    ctDigital = false;
    ctNonDigital = false;
    otherDigital = false;
    otherNonDigital = false;
    photographsDigital = false;
    photographsNonDigital = false;
    otherRadiographs = '';
    uploadedFiles = [];

    conditionOfJaws = '';
    otherDetails = '';

    placeOfDisaster = '';
    natureOfDisaster = '';
    dateOfDisaster = null;
    gender = '';

    _spec635.clear();

    super.notifyListeners(); // ‚Üê Ï†ÄÏû• Ïïà Ìï®
    });
    await LocalStore.resetDentalState();
  }

  bool _autosavePaused = false;

  T _withoutAutosave<T>(T Function() run) {
    final prev = _autosavePaused;
    _autosavePaused = true;
    try {
      return run();
    } finally {
      _autosavePaused = prev;
    }
  }

  @override
  void notifyListeners() {
    if (!_autosavePaused) {
      _scheduleAutosave(); // ‚Üê ÎîîÎ∞îÏö¥Ïä§ Î°úÏª¨ Ï†ÄÏû•
    }
    super.notifyListeners();
  }

  void _validateSpanConflicts() {
    final dent = <int>{};
    final br = <int>{};
    for (final sp in _spans) {
      final t = sp.teeth;
      if (sp.type == DentalSpanType.dentureOrtho) {
        final clash = t.where(br.contains).toList();
        if (clash.isNotEmpty) {
          debugPrint('‚ö†Ô∏è Î°úÎìúÎêú Îç∞Ïù¥ÌÑ∞Ïóê Denture/Bridge Ï∂©Îèå ÏûàÏùå: ${clash.join(", ")}');
        }
        dent.addAll(t);
      } else {
        final clash = t.where(dent.contains).toList();
        if (clash.isNotEmpty) {
          debugPrint('‚ö†Ô∏è Î°úÎìúÎêú Îç∞Ïù¥ÌÑ∞Ïóê Bridge/Denture Ï∂©Îèå ÏûàÏùå: ${clash.join(", ")}');
        }
        br.addAll(t);
      }
    }
  }
}

// import 'dart:async';
// import 'dart:collection';
// import 'dart:convert';
//
// import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:firebase_auth/firebase_auth.dart';
// import 'package:flutter/foundation.dart';
// import 'package:flutter/services.dart' show rootBundle;
//
// import '../data/codes_635.dart';
// import '../schema.dart';
// import '../services/local_store.dart';
//
// // ‚úÖ Î∑∞ Î™®Îìú (Ï∂ïÏÜå/ÌôïÎåÄ)
// enum ViewMode { zoomOut, zoomIn }
//
// // ‚úÖ Ï∂ïÏÜåÎ∑∞(DentalFindingsScreen)Îäî Ïù¥ Îëê Ïπ¥ÌÖåÍ≥†Î¶¨Îßå Îã§Î£∏
// const spanCategories = <String>{
//   'Denture and Orthodontic Appl.',
//   'Bridge',
// };
//
// // ‚úÖ Í≥ÑÏ∏µ ÏΩîÎìú ÎÖ∏Îìú
// class CodeNode {
//   final String code;
//   final String label;
//   final List<CodeNode> children;
//   bool get isLeaf => children.isEmpty;
//
//   CodeNode({required this.code, required this.label, this.children = const []});
//
//   factory CodeNode.fromMap(String code, Map<String, dynamic> m) {
//     final Map<String, dynamic> childMap = (m['children'] ?? {}) as Map<String, dynamic>;
//     return CodeNode(
//       code: code,
//       label: (m['label'] ?? code).toString(),
//       children: childMap.entries.map((e) => CodeNode.fromMap(e.key, e.value)).toList(),
//     );
//   }
//
//   Map<String, dynamic> toMap() => {
//     'code': code,
//     'label': label,
//     'children': [for (final c in children) c.toMap()],
//   };
// }
//
// // ‚úÖ Ïñ¥Îñ§ Î†àÎ≤®ÏóêÏÑúÎì† ÌôïÏ†ï Í∞ÄÎä•Ìïú ÏÑ†ÌÉù Í≤ΩÎ°ú
// class CodeSelection {
//   final String category; // Ïòà: "Bridge", "Crowns", ...
//   final List<String> path; // ["ABU","UIB","MTB"] Îì±. level1Îßå Ïç®ÎèÑ OK
//
//   const CodeSelection({required this.category, required this.path});
//
//   String get selected => path.isEmpty ? "" : path.last;
//   int get depth => path.length;
//
//   Map<String, dynamic> toMap() => {
//     "category": category,
//     "path": path,
//     "selected": selected,
//     "depth": depth,
//   };
//
//   factory CodeSelection.fromMap(Map<String, dynamic> m) =>
//       CodeSelection(
//         category: (m["category"] ?? "").toString(),
//         path: List<String>.from((m["path"] as List?) ?? const []),
//       );
// }
//
// /// 5Î©¥ ÌÇ§
// const List<String> kToothSurfaces = ['O', 'M', 'D', 'L', 'B'];
//
// // ===== Ïä§Ìå¨ Î™®Îç∏ =====
// enum DentalSpanType { dentureOrtho, bridge }
//
// class DentalSpan {
//   final String id;
//   final DentalSpanType type;
//   final Set<int> teeth;
//   final Set<int> abutments;
//   final Set<int> pontics;
//   final String? code;
//
//   DentalSpan({
//     required this.id,
//     required this.type,
//     required Set<int> teeth,
//     Set<int>? abutments,
//     Set<int>? pontics,
//     this.code,
//   })  : teeth = {...teeth},
//         abutments = {...(abutments ?? const <int>{})},
//         pontics = {...(pontics ?? const <int>{})};
//
//   Map<String, dynamic> toJson() => {
//     'id': id,
//     'type': type.name,
//     'teeth': teeth.toList(),
//     'abutments': abutments.toList(),
//     'pontics': pontics.toList(),
//     'code': code,
//   };
//
//   factory DentalSpan.fromJson(Map<String, dynamic> j) => DentalSpan(
//     id: (j['id'] ?? '').toString(),
//     type: DentalSpanType.values.firstWhere(
//           (e) => e.name == (j['type'] as String? ?? 'dentureOrtho'),
//       orElse: () => DentalSpanType.dentureOrtho,
//     ),
//     teeth: Set<int>.from(((j['teeth'] as List?) ?? const []).map((e) => int.parse(e.toString()))),
//     abutments: Set<int>.from(((j['abutments'] as List?) ?? const []).map((e) => int.parse(e.toString()))),
//     pontics: Set<int>.from(((j['pontics'] as List?) ?? const []).map((e) => int.parse(e.toString()))),
//     code: j['code'] as String?,
//   );
// }
//
// // ===== 635 Specific Data =====
// class SpecificData {
//   SpecificData();
//
//   final Map<String, List<String>> global = {
//     'bite': <String>[],
//     'crown': <String>[],
//     'root': <String>[],
//     'status': <String>[],
//     'position': <String>[],
//     'crown pathology': <String>[],
//   };
//
//   final Map<String, Map<String, List<String>>> surface = {
//     for (final s in kToothSurfaces)
//       s: {
//         'fillings': <String>[],
//         'periodontium': <String>[],
//       }
//   };
//
//   String? toothNote;
//   final Map<String, String> surfaceNote = <String, String>{};
//
//   Map<String, dynamic> toJson() => {
//     'global': global,
//     'surface': surface,
//     'toothNote': toothNote,
//     'surfaceNote': surfaceNote,
//   };
//
//   factory SpecificData.fromJson(Map<String, dynamic> j) {
//     final x = SpecificData();
//     final g = (j['global'] as Map?) ?? {};
//     for (final k in x.global.keys) {
//       x.global[k] = List<String>.from((g[k] as List?) ?? const []);
//     }
//     final sv = (j['surface'] as Map?) ?? {};
//     for (final s in kToothSurfaces) {
//       final m = (sv[s] as Map?) ?? {};
//       x.surface[s]!['fillings'] = List<String>.from((m['fillings'] as List?) ?? const []);
//       x.surface[s]!['periodontium'] = List<String>.from((m['periodontium'] as List?) ?? const []);
//     }
//     x.toothNote = j['toothNote'] as String?;
//     final sn = (j['surfaceNote'] as Map?) ?? {};
//     x.surfaceNote.addAll(sn.map((k, v) => MapEntry(k.toString(), v.toString())));
//     return x;
//   }
// }
//
// class DentalDataProvider extends ChangeNotifier {
//   DentalDataProvider({bool listenIncidentLock = true}) {
//     if (listenIncidentLock) _listenIncidentLock();
//   }
//
//   // ---------- Interpol ÏΩîÎìú Ìä∏Î¶¨ ----------
//   final Map<String, CodeNode> _codeRoots = {}; // Ïπ¥ÌÖåÍ≥†Î¶¨ ‚Üí Î£®Ìä∏
//   Set<String> _allCategories = {};
//   bool get hasCodeTree => _codeRoots.isNotEmpty;
//
//   Future<void> loadCodeTreeOnce() async {
//     if (_codeRoots.isNotEmpty) return;
//     final raw = await rootBundle.loadString('lib/data/prosthesis_tree.json');
//     final Map<String, dynamic> jsonMap = jsonDecode(raw);
//     _codeRoots.clear();
//     _allCategories = jsonMap.keys.toSet();
//     jsonMap.forEach((cat, body) {
//       final children = (body as Map<String, dynamic>).map((k, v) => MapEntry(k, CodeNode.fromMap(k, v)));
//       _codeRoots[cat] = CodeNode(code: cat, label: cat, children: children.values.toList());
//     });
//     notifyListeners();
//   }
//
//   List<String> availableCategories(ViewMode mode) {
//     if (_codeRoots.isEmpty) return const [];
//     if (mode == ViewMode.zoomOut) {
//       return _allCategories.where(spanCategories.contains).toList()..sort();
//     } else {
//       return _allCategories.where((c) => !spanCategories.contains(c)).toList()..sort();
//     }
//   }
//
//   CodeNode? _findNode(String category, List<String> path) {
//     final root = _codeRoots[category];
//     if (root == null) return null;
//     CodeNode cur = root;
//     for (final step in path) {
//       final idx = cur.children.indexWhere((n) => n.code.toLowerCase() == step.toLowerCase());
//       if (idx < 0) return null;
//       cur = cur.children[idx];
//     }
//     return cur;
//   }
//
//   List<CodeNode> listChildren(String category, List<String> path) =>
//       _findNode(category, path)?.children ?? const [];
//
//   bool isValidSelection(String category, List<String> path) => _findNode(category, path) != null;
//
//   // ---------- ÏÑ†ÌÉù ÏÉÅÌÉú ----------
//   CodeSelection? currentSelectionCompact; // Ï∂ïÏÜåÎ∑∞
//   CodeSelection? currentSelectionZoom; // ÌôïÎåÄÎ∑∞
//   void setSelectionFor(ViewMode mode, CodeSelection? sel) {
//     if (mode == ViewMode.zoomOut) {
//       currentSelectionCompact = sel;
//     } else {
//       currentSelectionZoom = sel;
//     }
//     notifyListeners();
//   }
//
//   // ---------- Ï¶êÍ≤®Ï∞æÍ∏∞ (ÌîÑÎ¶¨ÏÖã + Ïú†Ï†Ä) ----------
//   // ÌîÑÎ¶¨ÏÖã(ÎÑ§Í∞Ä Ï§Ä Î™©Î°ùÏùÑ Ïã§Ï†ú Ïπ¥ÌÖåÍ≥†Î¶¨Î°ú Îß§Ìïë)
//   // * Prosthesis(ipx)Îäî Ìä∏Î¶¨ÏÉÅ RootÏùò implant Í≥ÑÏó¥Ïù¥ÎØÄÎ°ú RootÎ°ú Î∞∞Ïπò
//   static final Map<String, List<List<String>>> _defaultFavByCat = {
//     // Status
//     'Status': [
//       ['int'], // intentional?
//       ['mam'],
//       ['mpm'],
//       ['car'],
//       ['cfr'],
//       ['imx'],
//       ['imv'],
//       ['eru'],
//     ],
//     // Root
//     'Root': [
//       ['rfx'],
//       ['rov'],
//       ['ipx'], // implant (ÌîÑÎ¶¨ÏÖã: Prothesis ‚Üí RootÎ°ú Îß§Ìïë)
//     ],
//     // Fillings
//     'Fillings': [
//       ['uif'],
//       ['cav'],
//       ['amf'],
//       ['tcf'],
//       ['cof'],
//       ['fis'],
//       ['goi'],
//       ['poi'],
//     ],
//     // Crowns
//     'Crowns': [
//       ['uic'],
//       ['mtc'],
//       ['goc'],
//       ['mec'],
//       ['tcc'],
//       ['mcc'],
//       ['poc'],
//       ['tec'],
//     ],
//     // Bridge
//     'Bridge': [
//       // ABU / MTB / GOB / MEB / TCB / MCB / POB / TEB / PON / CAN ...
//       ['abu'],
//       ['mtb'],
//       ['gob'],
//       ['meb'],
//       ['tcb'],
//       ['mcb'],
//       ['pob'],
//       ['teb'],
//       ['pon'],
//       ['can'],
//       // Î∏åÎ¶øÏßÄ Ïû¨Î£åÍµ∞ÎèÑ ÏùºÎ∂Ä Ìè¨Ìï®
//       ['mtc'],
//       ['goc'],
//       ['mec'],
//       ['tcc'],
//       ['mcc'],
//       ['poc'],
//       ['tec'],
//     ],
//     // Denture + Orthodontics Îäî ÌïòÎÇòÏùò Ïπ¥ÌÖåÍ≥†Î¶¨Î°ú Í¥ÄÎ¶¨Îê®
//     'Denture and Orthodontic Appl.': [
//       // Denture
//       ['fld'],
//       ['fud'],
//       ['pld'],
//       ['pud'],
//       // Orthodontics
//       ['foa'],
//       ['roa'],
//     ],
//   };
//
//   // Ïú†Ï†Ä Ï¶êÍ≤®Ï∞æÍ∏∞ Ï†ÄÏû•(Ïπ¥ÌÖåÍ≥†Î¶¨ ‚Üí pathKey Set)
//   final Map<String, Set<String>> _favUserByCat = {};
//
//   // key Ï°∞Ìï©(Ïπ¥ÌÖåÍ≥†Î¶¨ + Í≤ΩÎ°ú, ÏΩîÎìú ÎåÄÏÜåÎ¨∏Ïûê Î¨¥Ïãú)
//   String _favKey(String category, List<String> path) =>
//       '${category.trim()}|${path.map((e) => e.trim().toLowerCase()).join(">")}';
//
//   // ÌòÑÏû¨ Í≤ΩÎ°úÍ∞Ä Ï¶êÍ≤®Ï∞æÍ∏∞Ïù∏ÏßÄ(ÌîÑÎ¶¨ÏÖã or Ïú†Ï†Ä)
//   bool isFavoritePath(String category, List<String> path) {
//     final key = _favKey(category, path);
//     final preset = (_defaultFavByCat[category] ?? const [])
//         .map((p) => _favKey(category, p))
//         .contains(key);
//     final user = _favUserByCat[category]?.contains(key) ?? false;
//     return preset || user;
//   }
//
//   // Ïú†Ï†Ä Ï¶êÍ≤®Ï∞æÍ∏∞ ÌÜ†Í∏Ä
//   void toggleFavoritePath(String category, List<String> path) {
//     final key = _favKey(category, path);
//     final set = _favUserByCat.putIfAbsent(category, () => <String>{});
//     if (set.contains(key)) {
//       set.remove(key);
//     } else {
//       set.add(key);
//     }
//     notifyListeners();
//   }
//
//   // ÌòÑÏû¨ prefixÏóêÏÑú Î≥¥Ïù¥Îäî childrenÏùÑ "Ï¶êÍ≤®Ï∞æÍ∏∞ Ïö∞ÏÑ†"ÏúºÎ°ú Ï†ïÎ†¨
//   List<CodeNode> sortNodesWithFavorites({
//     required String category,
//     required List<String> currentPrefix,
//     required List<CodeNode> items,
//   }) {
//     // level1Îßå Ïì∏ Í±∞ÎùºÎ©¥ currentPrefixÎäî Î≥¥ÌÜµ []
//     final presetKeys = {
//       for (final p in (_defaultFavByCat[category] ?? const [])) _favKey(category, [...currentPrefix, ...p])
//     };
//     final userKeys = _favUserByCat[category] ?? const <String>{};
//
//     int favScoreFor(String code) {
//       final key = _favKey(category, [...currentPrefix, code]);
//       // ÌîÑÎ¶¨ÏÖã ÏµúÏö∞ÏÑ†(2), Ïú†Ï†Ä(1), ÏùºÎ∞ò(0)
//       if (presetKeys.contains(key)) return 2;
//       if (userKeys.contains(key)) return 1;
//       return 0;
//     }
//
//     final sorted = [...items];
//     sorted.sort((a, b) {
//       final sa = favScoreFor(a.code);
//       final sb = favScoreFor(b.code);
//       if (sa != sb) return sb.compareTo(sa); // ÎÜíÏùÄ Ï†êÏàò(Ï¶êÍ≤®Ï∞æÍ∏∞) Î®ºÏ†Ä
//       return a.code.compareTo(b.code);
//     });
//     return sorted;
//   }
//
//   // Ï¶êÍ≤®Ï∞æÍ∏∞(ÌîÑÎ¶¨ÏÖã+Ïú†Ï†Ä) Ìï©Ïπú Î™©Î°ùÏùÑ level1 ÏΩîÎìú Î¶¨Ïä§Ìä∏Î°ú Ï†úÍ≥µ (Ìä∏Î¶¨ UIÏóêÏÑú ‚ÄúÏ¶êÍ≤®Ï∞æÍ∏∞ ÏÑπÏÖò‚Äù ÎßåÎì§ Îïå ÏÇ¨Ïö©)
//   List<List<String>> effectiveFavoritesLevel1(String category) {
//     final preset = (_defaultFavByCat[category] ?? const <List<String>>[]);
//     final userKeys = _favUserByCat[category] ?? const <String>{};
//     final user = userKeys
//         .map((k) => k.split('|').last) // path Î∂ÄÎ∂ÑÎßå
//         .where((p) => p.isNotEmpty)
//         .map((p) => p.split('>'))
//         .where((path) => path.length >= 1)
//         .map((path) => <String>[path.first])
//         .toList();
//
//     // Ï§ëÎ≥µ Ï†úÍ±∞
//     final seen = <String>{};
//     List<List<String>> out = [];
//     for (final p in [...preset, ...user]) {
//       final k = _favKey(category, [p.first]);
//       if (seen.add(k)) out.add([p.first]);
//     }
//     return out;
//   }
//
//   // ---------- 635 Îç∞Ïù¥ÌÑ∞/Ïä§Ìå¨/Ï†ÄÏû• ----------
//   final Map<int, SpecificData> _spec635 = <int, SpecificData>{};
//   final List<DentalSpan> _spans = <DentalSpan>[];
//   UnmodifiableListView<DentalSpan> get spans => UnmodifiableListView(_spans);
//
//   Timer? _saveDebounce;
//   static int _idSeed = 0;
//
//   void _scheduleAutosave() {
//     _saveDebounce?.cancel();
//     _saveDebounce = Timer(const Duration(milliseconds: 300), () async {
//       await LocalStore.saveDentalState(toMap());
//     });
//   }
//
//   void _markDirty() {
//     _scheduleAutosave();
//     notifyListeners();
//   }
//
//   SpecificData? getSpecRead(int fdi) => _spec635[fdi];
//
//   SpecificData ensureSpec(int fdi) => _spec635.putIfAbsent(fdi, () => SpecificData());
//
//   void toggleGlobalCode(int fdi, String group, String code) {
//     final s = ensureSpec(fdi).global[group];
//     if (s == null) return;
//     if (s.contains(code)) {
//       s.remove(code);
//     } else {
//       s.add(code);
//     }
//     notifyListeners();
//   }
//
//   void toggleSurfaceCode(int fdi, String surface, String group, String code) {
//     if (!kToothSurfaces.contains(surface)) return;
//     final s = ensureSpec(fdi).surface[surface]?[group];
//     if (s == null) return;
//     if (s.contains(code)) {
//       s.remove(code);
//     } else {
//       s.add(code);
//     }
//     notifyListeners();
//   }
//
//   void setToothNote635(int fdi, String? note) {
//     ensureSpec(fdi).toothNote = (note?.trim().isNotEmpty ?? false) ? note!.trim() : null;
//     notifyListeners();
//   }
//
//   void setSurfaceNote635(int fdi, String surface, String note) {
//     if (!kToothSurfaces.contains(surface)) return;
//     ensureSpec(fdi).surfaceNote[surface] = note;
//     notifyListeners();
//   }
//
//   void clearSurface635(int fdi, String surface) {
//     if (!kToothSurfaces.contains(surface)) return;
//     final s = _spec635[fdi];
//     if (s == null) return;
//     s.surface[surface]?['fillings']?.clear();
//     s.surface[surface]?['periodontium']?.clear();
//     s.surfaceNote.remove(surface);
//     notifyListeners();
//   }
//
//   void clearGlobalAll635(int fdi) {
//     final spec = getSpecRead(fdi);
//     if (spec == null) return;
//     for (final g in k635GlobalCodes.keys) {
//       spec.global[g] = <String>[];
//     }
//     spec.toothNote = '';
//     notifyListeners();
//   }
//
//   // --- Incident Lock(remote) ---
//   String recordType = 'PM';
//   String amNumber = '';
//   String pmNumber = '';
//
//   bool incidentLockEnabled = false;
//   String lockedPlace = '';
//   String lockedNature = '';
//   String get placeForUi => (incidentLockEnabled && lockedPlace.isNotEmpty) ? lockedPlace : placeOfDisaster;
//   String get natureForUi => (incidentLockEnabled && lockedNature.isNotEmpty) ? lockedNature : natureOfDisaster;
//
//   final DocumentReference<Map<String, dynamic>> _lockDoc =
//   FirebaseFirestore.instance.collection('config').doc('incidentLock');
//   StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>? _lockSub;
//
//   void _listenIncidentLock() {
//     _lockSub = _lockDoc.snapshots().listen((snap) {
//       final d = snap.data();
//       if (d == null) return;
//       _withoutAutosave(() {
//         incidentLockEnabled = (d['enabled'] ?? false) as bool;
//         lockedPlace = (d['place'] ?? '') as String;
//         lockedNature = (d['nature'] ?? '') as String;
//         super.notifyListeners();
//       });
//     });
//   }
//
//   Future<void> setIncidentLockRemote({
//     required bool enabled,
//     required String place,
//     required String nature,
//   }) async {
//     if (enabled && (place.isEmpty || nature.isEmpty)) {
//       throw ArgumentError('Place/Nature required to enable incident lock.');
//     }
//     await _lockDoc.set(
//       {
//         'enabled': enabled,
//         'place': place,
//         'nature': nature,
//         'updatedAt': FieldValue.serverTimestamp(),
//         'byUid': FirebaseAuth.instance.currentUser?.uid,
//       },
//       SetOptions(merge: true),
//     );
//   }
//
//   @override
//   void dispose() {
//     _lockSub?.cancel();
//     _saveDebounce?.cancel();
//     super.dispose();
//   }
//
//   // ---------- Odontogram (Í≤ΩÎüâ ÏÉÅÌÉú) ----------
//   final Map<int, Map<String, dynamic>> fdiToothData = <int, Map<String, dynamic>>{};
//   final Map<int, Set<String>> _selectedSurfaces = <int, Set<String>>{};
//
//   Set<String> getSelectedSurfaces(int fdi) => _selectedSurfaces[fdi] ?? <String>{};
//
//   void toggleSurface(int fdi, String surfaceKey) {
//     if (!kToothSurfaces.contains(surfaceKey)) return;
//     final s = _selectedSurfaces.putIfAbsent(fdi, () => <String>{});
//     if (s.contains(surfaceKey)) {
//       s.remove(surfaceKey);
//     } else {
//       s.add(surfaceKey);
//     }
//     notifyListeners();
//   }
//
//   void clearSurfaces(int fdi) {
//     final s = _selectedSurfaces[fdi];
//     if (s == null) return;
//     s.clear();
//     notifyListeners();
//   }
//
//   // ---------- STEP 2: Denture/Bridge Ïä§Ìå¨ ----------
//   String _randId() => 'sp_${DateTime.now().microsecondsSinceEpoch}_$_idSeed';
//
//   List<DentalSpan> spansIntersecting(Iterable<int> fdis) {
//     final set = fdis.toSet();
//     return _spans.where((sp) => sp.teeth.any(set.contains)).toList();
//   }
//
//   bool _isUpperFdi(int fdi) {
//     final q = fdi ~/ 10;
//     return q == 1 || q == 2 || q == 5 || q == 6;
//   }
//
//   bool _allSameArch(Iterable<int> fdis) {
//     bool? first;
//     for (final f in fdis) {
//       final up = _isUpperFdi(f);
//       first ??= up;
//       if (up != first) return false;
//     }
//     return true;
//   }
//
//   bool _hasTypeConflictInternal(Iterable<int> teeth, DentalSpanType creating) {
//     final set = teeth.toSet();
//     return _spans.any((sp) => sp.type != creating && sp.teeth.any(set.contains));
//   }
//
//   void addDentureSpan(List<int> selectedFdi, {String? code}) {
//     if (selectedFdi.isEmpty) return;
//     if (!_allSameArch(selectedFdi)) {
//       debugPrint('‚ùå ÏÉÅ/ÌïòÏïÖ ÌòºÌï© Ïä§Ìå¨ Í∏àÏßÄ');
//       return;
//     }
//     if (_hasTypeConflictInternal(selectedFdi, DentalSpanType.dentureOrtho)) {
//       debugPrint('‚ùå Denture/Ortho ÏÉùÏÑ± Ïã§Ìå®: Ïù¥ÎØ∏ Bridge Ïä§Ìå¨Í≥º Í≤πÏπ©ÎãàÎã§.');
//       return;
//     }
//     _spans.add(DentalSpan(
//       id: _randId(),
//       type: DentalSpanType.dentureOrtho,
//       teeth: Set<int>.from(selectedFdi),
//       code: code,
//     ));
//     _markDirty();
//   }
//
//   void addBridgeSpan({
//     required List<int> selectedFdi,
//     required Set<int> abutments,
//     required Set<int> pontics,
//     String? code,
//   }) {
//     if (selectedFdi.isEmpty || abutments.isEmpty || pontics.isEmpty) return;
//     final union = {...selectedFdi, ...abutments, ...pontics};
//     if (!_allSameArch(union)) {
//       debugPrint('‚ùå ÏÉÅ/ÌïòÏïÖ ÌòºÌï© Î∏åÎ¶¨ÏßÄ Í∏àÏßÄ');
//       return;
//     }
//     if (_hasTypeConflictInternal(union, DentalSpanType.bridge)) {
//       debugPrint('‚ùå Bridge ÏÉùÏÑ± Ïã§Ìå®: Ïù¥ÎØ∏ Denture/Ortho Ïä§Ìå¨Í≥º Í≤πÏπ©ÎãàÎã§.');
//       return;
//     }
//     _spans.add(DentalSpan(
//       id: _randId(),
//       type: DentalSpanType.bridge,
//       teeth: Set<int>.from(selectedFdi),
//       abutments: abutments,
//       pontics: pontics,
//       code: code,
//     ));
//     _markDirty();
//   }
//
//   void removeSpan(String id) {
//     _spans.removeWhere((e) => e.id == id);
//     _markDirty();
//   }
//
//   int removeSpansIntersecting(Set<int> targets, {bool removeDenture = true, bool removeBridge = true}) {
//     final before = _spans.length;
//     _spans.removeWhere((sp) {
//       final hit = sp.teeth.any(targets.contains);
//       if (!hit) return false;
//       if (sp.type == DentalSpanType.dentureOrtho && !removeDenture) return false;
//       if (sp.type == DentalSpanType.bridge && !removeBridge) return false;
//       return true;
//     });
//     final removed = before - _spans.length;
//     if (removed > 0) _markDirty();
//     return removed;
//   }
//
//   // 635 Ìïú Ï§Ñ ÌîÑÎ¶¨Î∑∞
//   String build635Line(int fdi) {
//     final s = _spec635[fdi];
//     if (s == null) return '';
//     final out = <String>[];
//     for (final surf in kToothSurfaces) {
//       for (final grp in const ['fillings', 'periodontium']) {
//         final list = s.surface[surf]![grp]!;
//         if (list.isNotEmpty) out.add('${list.join(",")}($surf)');
//       }
//     }
//     for (final g in const ['bite', 'crown', 'root', 'status', 'position', 'crown pathology']) {
//       final list = s.global[g]!;
//       if (list.isNotEmpty) out.add(list.join(','));
//     }
//     if (s.toothNote != null && s.toothNote!.isNotEmpty) out.add('note:${s.toothNote}');
//     return out.join(' ¬∑ ');
//   }
//
//   Map<String, dynamic> exportSpecAll() => {
//     for (final e in _spec635.entries) e.key.toString(): e.value.toJson(),
//   };
//
//   // ---------- ÎÇòÎ®∏ÏßÄ Ìèº ÌïÑÎìú ----------
//   String otherFindings = "";
//   String dentitionType = "";
//   int? ageMin;
//   int? ageMax;
//   String qualityCheckSignature = "";
//   DateTime? qualityCheckDate;
//
//   bool upperJawWithTeeth = false;
//   bool lowerJawWithTeeth = false;
//   bool upperJawWithoutTeeth = false;
//   bool lowerJawWithoutTeeth = false;
//   bool fragments = false;
//   String teethOnly = '';
//   String otherMaterials = '';
//
//   bool paDigital = false;
//   bool paNonDigital = false;
//   bool bwDigital = false;
//   bool bwNonDigital = false;
//   bool opgDigital = false;
//   bool opgNonDigital = false;
//   bool ctDigital = false;
//   bool ctNonDigital = false;
//   bool otherDigital = false;
//   bool otherNonDigital = false;
//   bool photographsDigital = false;
//   bool photographsNonDigital = false;
//   String otherRadiographs = '';
//   List<String> uploadedFiles = [];
//
//   String conditionOfJaws = '';
//   String otherDetails = '';
//
//   String placeOfDisaster = '';
//   String natureOfDisaster = '';
//   DateTime? dateOfDisaster;
//   String gender = '';
//
//   // ---------- Updaters ----------
//   void updateRecordType(String type) {
//     if (type != 'PM' && type != 'AM') return;
//     if (recordType == type) return;
//     recordType = type;
//     notifyListeners();
//   }
//
//   void updateAmNumber(String value) {
//     if (amNumber == value) return;
//     amNumber = value;
//     notifyListeners();
//   }
//
//   void updatePmNumber(String pm) {
//     if (pmNumber == pm) return;
//     pmNumber = pm;
//     notifyListeners();
//   }
//
//   void updatePlace(String place) {
//     if (incidentLockEnabled) return;
//     placeOfDisaster = place;
//     notifyListeners();
//   }
//
//   void updateNature(String nature) {
//     if (incidentLockEnabled) return;
//     natureOfDisaster = nature;
//     notifyListeners();
//   }
//
//   void updateDisasterDate(DateTime date) {
//     dateOfDisaster = date;
//     notifyListeners();
//   }
//
//   void updateGender(String selectedGender) {
//     gender = selectedGender;
//     notifyListeners();
//   }
//
//   void updateOtherFindings(String value) {
//     otherFindings = value;
//     notifyListeners();
//   }
//
//   void updateDentitionType(String type) {
//     dentitionType = type;
//     notifyListeners();
//   }
//
//   void updateAgeMin(int? value) {
//     ageMin = value;
//     notifyListeners();
//   }
//
//   void updateAgeMax(int? value) {
//     ageMax = value;
//     notifyListeners();
//   }
//
//   void updateQualitySignature(String value) {
//     qualityCheckSignature = value;
//     notifyListeners();
//   }
//
//   void updateQualityDate(DateTime date) {
//     qualityCheckDate = date;
//     notifyListeners();
//   }
//
//   void setMaterialsAvailable({
//     required bool upperWith,
//     required bool lowerWith,
//     required bool upperWithout,
//     required bool lowerWithout,
//     required bool hasFragments,
//     required String teethText,
//     required String otherText,
//   }) {
//     upperJawWithTeeth = upperWith;
//     lowerJawWithTeeth = lowerWith;
//     upperJawWithoutTeeth = upperWithout;
//     lowerJawWithoutTeeth = lowerWithout;
//     fragments = hasFragments;
//     teethOnly = teethText;
//     otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setEachMaterial({
//     bool? upperWith,
//     bool? lowerWith,
//     bool? upperWithout,
//     bool? lowerWithout,
//     bool? hasFragments,
//     String? teethText,
//     String? otherText,
//   }) {
//     if (upperWith != null) upperJawWithTeeth = upperWith;
//     if (lowerWith != null) lowerJawWithTeeth = lowerWith;
//     if (upperWithout != null) upperJawWithoutTeeth = upperWithout;
//     if (lowerWithout != null) lowerJawWithoutTeeth = lowerWithout;
//     if (hasFragments != null) fragments = hasFragments;
//     if (teethText != null) teethOnly = teethText;
//     if (otherText != null) otherMaterials = otherText;
//     notifyListeners();
//   }
//
//   void setDentalImages({
//     bool? paD,
//     bool? paND,
//     bool? bwD,
//     bool? bwND,
//     bool? opgD,
//     bool? opgND,
//     bool? ctD,
//     bool? ctND,
//     bool? otherD,
//     bool? otherND,
//     bool? photoD,
//     bool? photoND,
//     String? otherRadio,
//     List<String>? uploads,
//   }) {
//     if (paD != null) paDigital = paD;
//     if (paND != null) paNonDigital = paND;
//     if (bwD != null) bwDigital = bwD;
//     if (bwND != null) bwNonDigital = bwND;
//     if (opgD != null) opgDigital = opgD;
//     if (opgND != null) opgNonDigital = opgND;
//     if (ctD != null) ctDigital = ctD;
//     if (ctND != null) ctNonDigital = ctND;
//     if (otherD != null) otherDigital = otherD;
//     if (otherND != null) otherNonDigital = otherND;
//     if (photoD != null) photographsDigital = photoD;
//     if (photoND != null) photographsNonDigital = photoND;
//     if (otherRadio != null) otherRadiographs = otherRadio;
//     if (uploads != null) uploadedFiles = uploads;
//     notifyListeners();
//   }
//
//   void setConditionOfJaws(String value) {
//     conditionOfJaws = value;
//     notifyListeners();
//   }
//
//   void setOtherDetails(String value) {
//     otherDetails = value;
//     notifyListeners();
//   }
//
//   void setFdiToothData(Map<int, Map<String, String>> newData) {
//     fdiToothData.clear();
//     fdiToothData.addAll(newData);
//     notifyListeners();
//   }
//
//   void addUploadedFile(String fileUrl) {
//     uploadedFiles.add(fileUrl);
//     notifyListeners();
//   }
//
//   void removeUploadedFile(String fileUrl) {
//     uploadedFiles.remove(fileUrl);
//     notifyListeners();
//   }
//
//   // ---------- Reset / Save ----------
//   Map<String, dynamic> toMap() {
//     final effectivePlace = (incidentLockEnabled && lockedPlace.isNotEmpty) ? lockedPlace : placeOfDisaster;
//     final effectiveNature = (incidentLockEnabled && lockedNature.isNotEmpty) ? lockedNature : natureOfDisaster;
//
//     return {
//       '_v': Schema.current,
//       'recordType': recordType,
//       'amNumber': amNumber,
//       'pmNumber': pmNumber,
//       'placeOfDisaster': effectivePlace,
//       'placeNorm': (effectivePlace).trim().toLowerCase(),
//       'natureOfDisaster': effectiveNature,
//       'dateOfDisaster': dateOfDisaster?.toIso8601String(),
//       'gender': gender,
//
//       'fdiToothData': {for (final e in fdiToothData.entries) e.key.toString(): e.value},
//       'spans': _spans.map((e) => e.toJson()).toList(),
//       'spec635': {for (final e in _spec635.entries) e.key.toString(): e.value.toJson()},
//
//       'otherFindings': otherFindings,
//       'dentitionType': dentitionType,
//       'ageMin': ageMin,
//       'ageMax': ageMax,
//       'qualityCheckSignature': qualityCheckSignature,
//       'qualityCheckDate': qualityCheckDate?.toIso8601String(),
//
//       'upperJawWithTeeth': upperJawWithTeeth,
//       'lowerJawWithTeeth': lowerJawWithTeeth,
//       'upperJawWithoutTeeth': upperJawWithoutTeeth,
//       'lowerJawWithoutTeeth': lowerJawWithoutTeeth,
//       'fragments': fragments,
//       'teethOnly': teethOnly,
//       'otherMaterials': otherMaterials,
//
//       'paDigital': paDigital,
//       'paNonDigital': paNonDigital,
//       'bwDigital': bwDigital,
//       'bwNonDigital': bwNonDigital,
//       'opgDigital': opgDigital,
//       'opgNonDigital': opgNonDigital,
//       'ctDigital': ctDigital,
//       'ctNonDigital': ctNonDigital,
//       'otherDigital': otherDigital,
//       'otherNonDigital': otherNonDigital,
//       'photographsDigital': photographsDigital,
//       'photographsNonDigital': photographsNonDigital,
//       'otherRadiographs': otherRadiographs,
//       'uploadedFiles': uploadedFiles,
//
//       'conditionOfJaws': conditionOfJaws,
//       'otherDetails': otherDetails,
//
//       'codeSelectionCompact': currentSelectionCompact?.toMap(),
//       'codeSelectionZoom': currentSelectionZoom?.toMap(),
//
//       // ‚úÖ Ïú†Ï†Ä Ï¶êÍ≤®Ï∞æÍ∏∞ Ï†ÄÏû• (Ïπ¥ÌÖåÍ≥†Î¶¨ ‚Üí Í≤ΩÎ°úÎ¶¨Ïä§Ìä∏(Î¶¨Ïä§Ìä∏Ìòï))
//       'favoritesUser': {
//         for (final entry in _favUserByCat.entries)
//           entry.key: entry.value
//               .map((key) => key.split('|').last) // "a>b>c"
//               .map((p) => p.split('>')) // ["a","b","c"]
//               .toList(),
//       },
//     };
//   }
//
//   void fromMap(Map<String, dynamic> m) {
//     final ver = (m['_v'] is int) ? m['_v'] as int : 1;
//
//     T _get<T>(String k, T fallback) {
//       final v = m[k];
//       return (v is T) ? v : fallback;
//     }
//
//     recordType = _get<String>('recordType', 'PM');
//     amNumber = _get<String>('amNumber', '');
//     pmNumber = _get<String>('pmNumber', '');
//     placeOfDisaster = _get<String>('placeOfDisaster', '');
//     natureOfDisaster = _get<String>('natureOfDisaster', '');
//     final dateStr = m['dateOfDisaster'] as String?;
//     dateOfDisaster = (dateStr == null || dateStr.isEmpty) ? null : DateTime.tryParse(dateStr);
//     gender = _get<String>('gender', '');
//
//     fdiToothData
//       ..clear()
//       ..addAll(((m['fdiToothData'] as Map?) ?? const {}).map(
//             (k, v) => MapEntry(int.parse(k.toString()), Map<String, dynamic>.from(v as Map)),
//       ));
//
//     _spec635
//       ..clear()
//       ..addAll(((m['spec635'] as Map?) ?? const {}).map(
//             (k, v) => MapEntry(int.parse(k.toString()), SpecificData.fromJson(Map<String, dynamic>.from(v as Map))),
//       ));
//
//     _spans
//       ..clear()
//       ..addAll(((m['spans'] as List?) ?? const [])
//           .whereType<Map>()
//           .map((e) => DentalSpan.fromJson(e.map((k, v) => MapEntry(k.toString(), v)))));
//
//     otherFindings = _get<String>('otherFindings', '');
//     dentitionType = _get<String>('dentitionType', '');
//     ageMin = m['ageMin'] is int ? m['ageMin'] as int : null;
//     ageMax = m['ageMax'] is int ? m['ageMax'] as int : null;
//     qualityCheckSignature = _get<String>('qualityCheckSignature', '');
//     final qDateStr = m['qualityCheckDate'] as String?;
//     qualityCheckDate = (qDateStr == null || qDateStr.isEmpty) ? null : DateTime.tryParse(qDateStr);
//
//     upperJawWithTeeth = _get<bool>('upperJawWithTeeth', false);
//     lowerJawWithTeeth = _get<bool>('lowerJawWithTeeth', false);
//     upperJawWithoutTeeth = _get<bool>('upperJawWithoutTeeth', false);
//     lowerJawWithoutTeeth = _get<bool>('lowerJawWithoutTeeth', false);
//     fragments = _get<bool>('fragments', false);
//     teethOnly = _get<String>('teethOnly', '');
//     otherMaterials = _get<String>('otherMaterials', '');
//
//     paDigital = _get<bool>('paDigital', false);
//     paNonDigital = _get<bool>('paNonDigital', false);
//     bwDigital = _get<bool>('bwDigital', false);
//     bwNonDigital = _get<bool>('bwNonDigital', false);
//     opgDigital = _get<bool>('opgDigital', false);
//     opgNonDigital = _get<bool>('opgNonDigital', false);
//     ctDigital = _get<bool>('ctDigital', false);
//     ctNonDigital = _get<bool>('ctNonDigital', false);
//     otherDigital = _get<bool>('otherDigital', false);
//     otherNonDigital = _get<bool>('otherNonDigital', false);
//     photographsDigital = _get<bool>('photographsDigital', false);
//     photographsNonDigital = _get<bool>('photographsNonDigital', false);
//     otherRadiographs = _get<String>('otherRadiographs', '');
//     uploadedFiles = List<String>.from((m['uploadedFiles'] as List?) ?? const []);
//
//     conditionOfJaws = _get<String>('conditionOfJaws', '');
//     otherDetails = _get<String>('otherDetails', '');
//
//     // ÏΩîÎìú ÏÑ†ÌÉù Î≥µÏõê
//     final csc = m['codeSelectionCompact'];
//     currentSelectionCompact = (csc is Map) ? CodeSelection.fromMap(csc.map((k, v) => MapEntry(k.toString(), v))) : null;
//     final csz = m['codeSelectionZoom'];
//     currentSelectionZoom = (csz is Map) ? CodeSelection.fromMap(csz.map((k, v) => MapEntry(k.toString(), v))) : null;
//
//     // Ïú†Ï†Ä Ï¶êÍ≤®Ï∞æÍ∏∞ Î≥µÏõê
//     _favUserByCat.clear();
//     final fav = (m['favoritesUser'] as Map?) ?? {};
//     fav.forEach((cat, list) {
//       final catStr = cat.toString();
//       final paths = (list as List? ?? const [])
//           .whereType<List>()
//           .map((p) => List<String>.from(p))
//           .map((path) => _favKey(catStr, path))
//           .toSet();
//       if (paths.isNotEmpty) {
//         _favUserByCat[catStr] = paths;
//       }
//     });
//
//     _validateSpanConflicts();
//   }
//
//   Future<void> hydrate() async {
//     final data = LocalStore.loadDentalState();
//     if (data != null) {
//       _withoutAutosave(() {
//         fromMap(data);
//         super.notifyListeners();
//       });
//     }
//   }
//
//   Future<void> resetAll() async {
//     _withoutAutosave(() {
//       recordType = 'PM';
//       amNumber = '';
//       pmNumber = '';
//
//       fdiToothData.clear();
//       _selectedSurfaces.clear();
//       _spans.clear();
//
//       otherFindings = "";
//       dentitionType = "";
//       ageMin = null;
//       ageMax = null;
//       qualityCheckSignature = "";
//       qualityCheckDate = null;
//
//       upperJawWithTeeth = false;
//       lowerJawWithTeeth = false;
//       upperJawWithoutTeeth = false;
//       lowerJawWithoutTeeth = false;
//       fragments = false;
//       teethOnly = '';
//       otherMaterials = '';
//
//       paDigital = false;
//       paNonDigital = false;
//       bwDigital = false;
//       bwNonDigital = false;
//       opgDigital = false;
//       opgNonDigital = false;
//       ctDigital = false;
//       ctNonDigital = false;
//       otherDigital = false;
//       otherNonDigital = false;
//       photographsDigital = false;
//       photographsNonDigital = false;
//       otherRadiographs = '';
//       uploadedFiles = [];
//
//       conditionOfJaws = '';
//       otherDetails = '';
//
//       placeOfDisaster = '';
//       natureOfDisaster = '';
//       dateOfDisaster = null;
//       gender = '';
//
//       _spec635.clear();
//       _favUserByCat.clear();
//
//       super.notifyListeners();
//     });
//     await LocalStore.resetDentalState();
//   }
//
//   bool _autosavePaused = false;
//
//   T _withoutAutosave<T>(T Function() run) {
//     final prev = _autosavePaused;
//     _autosavePaused = true;
//     try {
//       return run();
//     } finally {
//       _autosavePaused = prev;
//     }
//   }
//
//   @override
//   void notifyListeners() {
//     if (!_autosavePaused) {
//       _scheduleAutosave();
//     }
//     super.notifyListeners();
//   }
//
//   void _validateSpanConflicts() {
//     final dent = <int>{};
//     final br = <int>{};
//     for (final sp in _spans) {
//       final t = sp.teeth;
//       if (sp.type == DentalSpanType.dentureOrtho) {
//         final clash = t.where(br.contains).toList();
//         if (clash.isNotEmpty) {
//           debugPrint('‚ö†Ô∏è Î°úÎìúÎêú Îç∞Ïù¥ÌÑ∞Ïóê Denture/Bridge Ï∂©Îèå ÏûàÏùå: ${clash.join(", ")}');
//         }
//         dent.addAll(t);
//       } else {
//         final clash = t.where(dent.contains).toList();
//         if (clash.isNotEmpty) {
//           debugPrint('‚ö†Ô∏è Î°úÎìúÎêú Îç∞Ïù¥ÌÑ∞Ïóê Bridge/Denture Ï∂©Îèå ÏûàÏùå: ${clash.join(", ")}');
//         }
//         br.addAll(t);
//       }
//     }
//   }
// }
